---
title: '2021'
author: "Sonia Mitchell"
date: "05/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(dplyr)
library(tidyr)
```

## Day 1: Sonar Sweep

Link to questions [here](https://adventofcode.com/2021/day/1)

### Part 1

```{r day1-1}
# Read in data
dat <- scan(file.path(here(), "inst", "2021", "day1.txt"))

# Count the number of times the depth increases from the previous measurement
sum(diff(dat) > 0)
```

### Part 2

```{r day1-2}
# Sum depths in each window
index <- 1
summed <- c()
while((index + 2) <= length(dat)) {
  summed <- c(summed, sum(dat[index:(index + 2)]))
  index <- index + 1
}

# Count the number of times the depth increases from the previous measurement
sum(diff(summed) > 0)
```

## Day 2: Dive!

Link to questions [here](https://adventofcode.com/2021/day/2)

### Part 1

```{r day2-1}
# Read in data
dat <- read.table(file.path(here(), "inst", "2021", "day2.txt"))
colnames(dat) <- c("direction", "value")

# Calculate the horizontal position and depth and multiply them together
summarise_dat <- dat %>% 
  group_by(direction) %>% 
  summarise(total = sum(value)) 

horizontal_position <- summarise_dat$total[summarise_dat$direction == "forward"]
depth <- summarise_dat$total[summarise_dat$direction == "down"] - 
  summarise_dat$total[summarise_dat$direction == "up"]

horizontal_position * depth
```

### Part 2

```{r day2-2}
# Initialise variables
aim <- 0
horizontal_position <- 0
depth <- 0

# Track aim
for (i in seq_len(nrow(dat))) {
  if (dat$direction[i] == "down") {
    aim <- aim  + dat$value[i]
  } else if (dat$direction[i] == "up") {
    aim <- aim  - dat$value[i]
  } else {
    horizontal_position <- horizontal_position + dat$value[i]
    depth <- depth + (aim * dat$value[i])
  }
}

horizontal_position * depth
```

## Day 3: Binary Diagnostic

Link to questions [here](https://adventofcode.com/2021/day/3)

### Part 1

```{r day3-1}
# Read in data
dat <- scan(file.path(here(), "inst", "2021", "day3.txt"), what = "character") 

# Number of bits in each binary number
digits <- nchar(dat[1])

# Calculate gamma and epsilon rates
gamma_binary <- rep(NA, digits)
epsilon_binary <- rep(NA, digits)

for (i in seq_len(digits)) {
  # Extract the i[th] character of each string 
  character <- vapply(dat, function(x) substr(x, i, i), character(1))
  # Find most common bit
  zeroes <- sum(character == "0")
  ones <- sum(character == "1")
  gamma_binary[i] <- if_else(zeroes > ones, 0, 1)
  epsilon_binary[i] <- if_else(zeroes < ones, 0, 1)
}

gamma_rate <- strtoi(paste(gamma_binary, collapse = ""), base = 2)
epsilon_rate <- strtoi(paste(epsilon_binary, collapse = ""), base = 2)

# Calculate power consumption
gamma_rate * epsilon_rate
```

### Part 2

```{r day3-2}
rating <- function(dat, type) {
  # For each bit in a binary string
  for (i in seq_len(digits)) {
    # Extract the i[th] character of each string 
    character <- vapply(dat, function(x) substr(x, i, i), 
                        character(1))
    # Find zeroes and ones
    zeroes <- character == "0"
    ones <- character == "1"
    # Find most common bit
    if (sum(zeroes) > sum(ones)) { 
      bit_criteria <- which(zeroes)
    } else if (sum(zeroes) < sum(ones)) { 
      bit_criteria <- which(ones)
    } else { 
      bit_criteria <- which(ones)
    }
    # Keep binary strings with most common bit in the ith position
    if (type == "oxygen") {
      dat <- dat[bit_criteria]
    } else if (type == "CO2") {
      dat <- dat[-bit_criteria]
    }
    # If there's only one binary string left, stop
    if (length(dat) == 1) break
  }
  # Return decimal
  strtoi(paste(dat, collapse = ""), base = 2)
}

# Calculate oxygen generator and CO2 scrubber ratings
oxygen_generator_rating <- rating(dat, "oxygen")
CO2_scrubber_rating <- rating(dat, "CO2")

# Calculate life support rating
oxygen_generator_rating * CO2_scrubber_rating
```

## Day 4: Giant Squid

Link to questions [here](https://adventofcode.com/2021/day/4)

### Part 1

```{r day4-1}
# Read in data
raw_numbers <- scan(file.path(here(), "inst", "2021", "day4.txt"), 
                    what = "character", n = 1) 
raw_boards <- read.table(file.path(here(), "inst", "2021", "day4.txt"), skip = 1)

# Tidy up data
numbers <- as.numeric(strsplit(raw_numbers, ",")[[1]])

number_of_boards <- nrow(raw_boards) / 5
boards <- lapply(seq_len(number_of_boards), function(x) {
  start <- 1 + (5 * (x - 1))
  end <- start + 4
  raw_boards[start:end, ]
})

update_board <- function(number, board) {
  check_number <- board == number
  if (any(check_number, na.rm = TRUE)) {
    # Mark the number
    find_number <- which(check_number, arr.ind = TRUE)
    board[find_number] <- NA
  }
  board
}

check_for_win <- function(board) {
  check_board <- is.na(board)
  row_win <- any(rowSums(check_board) == 5)
  column_win <- any(colSums(check_board) == 5)
  if_else(row_win | column_win, TRUE, FALSE)
}

play_bingo <- function(numbers, boards) {
  # For each number in the bingo call
  for (this_number in numbers) {
    # Check each board
    for (i in seq_along(boards)) {
      # If the number is on the board, mark it off (as NA) 
      boards[[i]] <- update_board(this_number, boards[[i]])
      # Check for win
      has_won <- check_for_win(boards[[i]])
      # If this board has won, calculate the winning score
      if (has_won) 
        return(sum(boards[[i]], na.rm = TRUE) * this_number)
    } 
  }
}

# Play bingo
play_bingo(numbers, boards)
```

### Part 2

```{r day4-2}
lose_bingo <- function(numbers, boards) {
  # Initialise objects
  results <- data.frame(number = numeric(), board = numeric(), score = numeric())
  remaining_boards <- seq_along(boards)
  
  # For each number in the bingo call
  for (this_number in numbers) {
    # Check each board
    for (i in remaining_boards) {
      # If the number is on the board, mark it off (as NA) 
      boards[[i]] <- update_board(this_number, boards[[i]])
      # Check for win
      has_won <- check_for_win(boards[[i]])
      # If this board has won, calculate the winning score
      if (has_won) {
        score <- sum(boards[[i]], na.rm = TRUE) * this_number
        results <- rbind(results, 
                         data.frame(number = this_number, 
                                    board = i, 
                                    score = score))
        remaining_boards <- remaining_boards[-which(remaining_boards == i)]
      }
    } 
  }
  results
}

# Play bingo
losers <- lose_bingo(numbers, boards)
tail(losers)
```

## Day 5: Hydrothermal Venture

Link to questions [here](https://adventofcode.com/2021/day/5)

### Part 1

```{r day5-1}
# Read in data
dat <- read.table(file.path(here(), "inst", "2021", "day5.txt"))

# Tidy up data
coordinates <- dat %>% 
  select(-V2) %>% 
  separate(V1, c("x1", "y1")) %>% 
  separate(V3, c("x2", "y2")) %>% 
  mutate(across(everything(), as.numeric))

# Initialise object
xlim <- max(c(coordinates$x1, coordinates$x2))
ylim <- max(c(coordinates$y1, coordinates$y2))
grid <- matrix(0, nrow = ylim, ncol = xlim)

# Track horizontal and vertical lines
for (i in seq_len(nrow(coordinates))) {
  this_line <- coordinates[i, ]
  
  if (this_line$x1 == this_line$x2) {
    # Horizontal line
    this_x <- this_line$x1
    y_values <- this_line$y1:this_line$y2
    # Add one to each point on the line
    for (y in y_values) grid[this_x, y] <- grid[this_x, y] + 1
    
  } else if (this_line$y1 == this_line$y2) {
    # Vertical line
    this_y <- this_line$y1
    x_values <- this_line$x1:this_line$x2
    # Add one to each point on the line
    for (x in x_values) grid[x, this_y] <- grid[x, this_y] + 1
  }
}

# Find points where at least two lines overlap
sum(grid >= 2)
```

### Part 2

```{r day5-2}
# Initialise object
grid <- matrix(0, nrow = ylim, ncol = xlim)

# Track horizontal, vertical lines, and diagonal lines
for (i in seq_len(nrow(coordinates))) {
  this_line <- coordinates[i, ]
  
  if (this_line$x1 == this_line$x2) {
    # Horizontal line
    this_x <- this_line$x1
    y_values <- this_line$y1:this_line$y2
    # Add one to each point on the line
    for (y in y_values) grid[this_x, y] <- grid[this_x, y] + 1
    
  } else if (this_line$y1 == this_line$y2) {
    # Vertical line
    this_y <- this_line$y1
    x_values <- this_line$x1:this_line$x2
    # Add one to each point on the line
    for (x in x_values) grid[x, this_y] <- grid[x, this_y] + 1
    
  } else if(abs(this_line$x1 - this_line$x2) == abs(this_line$y1 - this_line$y2)) {
    # Diagonal line
    x_values <- this_line$x1:this_line$x2
    y_values <- this_line$y1:this_line$y2
    # Add one to each point on the line
    for (i in seq_along(x_values)) 
      grid[x_values[i], y_values[i]] <- grid[x_values[i], y_values[i]] + 1
  }
}

# Find points where at least two lines overlap
sum(grid >= 2)
```

## Day 6: Lanternfish

Link to questions [here](https://adventofcode.com/2021/day/6)

### Part 1

```{r day6-1}
# Read in data
dat <- scan(file.path(here(), "inst", "2021", "day6.txt"), 
            what = "character", sep = ",") %>% 
  as.numeric()

# Initialise variables
days <- 80
fish <- dat

# Simulate lanternfish
for (i in seq_len(days)) {
  # Find zeroes
  zeroes <- which(fish == 0)
  # Subtract 1 from all fish
  fish <- fish - 1
  # Reset zeroes to six
  fish[zeroes] <- 6
  # Add eights for each zero
  fish <- c(fish, rep(8, length(zeroes)))
}

# How many lanternfish would there be after 80 days?
length(fish)
```

### Part 2

It takes too much memory to simulate individual fish in a vector, so generate
a frequency table instead.

```{r day6-2}
# Initialise variables
days <- 256

# Generate a frequency table
fish_counts <- data.frame(age = dat) %>% 
  # Count fish
  dplyr::count(age) %>% 
  # Fill in the missing categories
  complete(age = 0:8, fill = list(n = 0))

for (i in seq_len(days)) {
  # Number of zeroes
  n_zeroes <- fish_counts$n[fish_counts$age == 0]
  # Subtract 1 from all fish
  fish_counts$n[1:(nrow(fish_counts) - 1)] <- fish_counts$n[2:nrow(fish_counts)]
  # Reset zeroes to six
  age_6 <- which(fish_counts$age == 6)
  fish_counts$n[age_6] <- fish_counts$n[age_6] + n_zeroes
  # Add eights for each zero
  fish_counts$n[which(fish_counts$age == 8)] <- n_zeroes
}

# How many lanternfish would there be after 256 days?
sum(fish_counts$n) %>% 
  format(scientific = FALSE)
```

## Day 7: The Treachery of Whales

Link to questions [here](https://adventofcode.com/2021/day/7)

### Part 1

```{r day7-1}
# Read in data
dat <- scan(file.path(here(), "inst", "2021", "day7.txt"), 
            what = "character", sep = ",") %>% 
  as.numeric()

# Initialise objects
xlim <- max(dat)
results <- data.frame(x = 1:xlim, total_fuel_cost = NA)

# Determine the horizontal position that the crabs can align to using the least 
# fuel possible
for (position in seq_len(xlim)) {
  fuel_cost <- 0
  for (crab in dat) {
    fuel_cost <- fuel_cost + abs(crab - position)
  }
  results$total_fuel_cost[i] <- sum(fuel_cost)
}

lowest <- which.min(results$total_fuel_cost)
results$x[lowest]

# How much fuel must they spend to align to that position?
results$total_fuel_cost[lowest]
```

### Part 2

```{r day7-2}
# Initialise objects
results <- data.frame(x = 1:xlim, total_fuel_cost = NA)

# Determine the horizontal position that the crabs can align to using the least 
# fuel possible
for (position in seq_len(xlim)) {
  fuel_cost <- 0
  for (crab in dat) {
    distance <- abs(crab - position)
    fuel_cost <- fuel_cost + sum(0:distance)
  }
  results$total_fuel_cost[position] <- sum(fuel_cost)
}

lowest <- which.min(results$total_fuel_cost)
results$x[lowest]

# How much fuel must they spend to align to that position?
results$total_fuel_cost[lowest]
```

## Day 8: Seven Segment Search

Link to questions [here](https://adventofcode.com/2021/day/8)

### Part 1

```{r day8-1}
# Read in data
dat <- scan(file.path(here(), "inst", "2021", "day8.txt"), 
            what = "character", sep = "\n")

# Tidy up data
results <- c()
for (i in seq_along(dat)) {
  tmp <- strsplit(dat[i], "\\| ")[[1]][2]
  digits <- strsplit(tmp, " ")[[1]]
  results[i] <- sum(nchar(digits) %in% c(2, 4, 3, 7))
}

# How many times do digits 1, 4, 7, or 8 (length 2, 4, 3, and 7) appear?
sum(results)
```

### Part 2

```{r day8-2}
# Find string in `string_vector` of length `num_characters`
find_digit <- function(string_vector, num_characters) {
  string_vector[which(nchar(string_vector) == num_characters)]
}

# Split string into vector of letters
deconstruct <- function(string) {
  strsplit(string, "")[[1]]
}

# Find (1) which string in `unknown_vector` contains all segments (characters)  
# in `known_string` or (2) which string is the only one that doesn't
contains_subset <- function(unknown_vector, known_string, contains = TRUE) {
  results <- c()
  for (i in seq_along(unknown_vector)) {
    known_segments <- deconstruct(known_string)
    unknown_segments <- deconstruct(unknown_vector[i])
    if (contains) {
      results[i] <- all(known_segments %in% unknown_segments)
    } else {
      results[i] <- !all(known_segments %in% unknown_segments)
    }
  }
  unknown_vector[which(results)]
}

# Find the string in `unknown_vector` whose segments (characters) are a subset of
# `known_string` 
subset_of <- function(unknown_vector, known_string) {
  results <- c()
  for (i in seq_along(unknown_vector)) {
    known_segments <- deconstruct(known_string)
    unknown_segments <- deconstruct(unknown_vector[i])
    results[i] <- all(unknown_segments %in% known_segments)
  }
  unknown_vector[which(results)]
}

# Decode each string (digit) in `unknown_vector`
decode <- function(unknown_vector, dictionary) {
  code <- c()
  for (i in seq_along(unknown_vector)) {
    # Check against each dictionary entry
    entry <- c()
    for (j in seq_len(nrow(dictionary))) {
      length_match <- nchar(dictionary$segments[j]) == nchar(unknown_vector[i])
      characters_match <- all(deconstruct(dictionary$segments[j]) %in% 
                                deconstruct(unknown_vector[i]))
      entry[j] <- length_match && characters_match
    }
    code[i] <- dictionary$number[which(entry)]
  }
  as.numeric(paste(code, collapse = ""))
}

# Determine all of the wire/segment connections 
results <- c()
for (i in seq_along(dat)) {
  segments <- strsplit(dat[i], " \\|")[[1]][1]
  segments <- strsplit(segments, " ")[[1]]
  
  # Known
  one <- find_digit(segments, 2)
  four <- find_digit(segments, 4)
  seven <- find_digit(segments, 3)
  eight <- find_digit(segments, 7)
  
  # Remaining segments
  remaining <- segments[-which(nchar(segments) %in% c(2, 4, 3, 7))]
  # six, nine, zero (6)
  length_six <- remaining[which(nchar(remaining) == 6)]
  six <- contains_subset(length_six, one, FALSE)
  nine <- contains_subset(length_six, four, TRUE)
  zero <- length_six[!(length_six %in% c(six, nine))]
  # two, three, five (5)
  length_five <- remaining[which(nchar(remaining) == 5)]
  five <- subset_of(length_five, six)
  length_five <- length_five[!length_five %in% five]
  three <- subset_of(length_five, nine)
  two <- length_five[!length_five %in% three]
  
  # Initialise dictionary
  dict <- data.frame(number = 0:9, 
                     segments = c(zero, one, two, three, four, 
                                  five, six, seven, eight, nine))
  
  # Decode the four-digit output values
  digits <- strsplit(dat[i], "\\| ")[[1]][2]
  digits <- strsplit(digits, " ")[[1]]
  results[i] <- decode(digits, dict)
}

# What do you get if you add up all of the output values?
sum(results)
```

## Day 9: Smoke Basin

Link to questions [here](https://adventofcode.com/2021/day/9)

### Part 1

```{r day9-1}
# Read in data
dat <- readLines(file.path(here(), "inst", "2021", "day9.txt")) %>% 
  strsplit("") %>% 
  do.call(rbind, .) %>% 
  apply(1, as.numeric)

# Find `height` of adjacent points and if it's lower than all `adjacent_points`, 
# return risk level
compare_heights <- function(dat, row, column) {
  height <- dat[row, column]
  # Extract adjacent heights
  adjacent_points <- c()
  if (i != 1)
    adjacent_points <- c(adjacent_points, dat[row - 1, column]) # above
  if (j != ncol(dat))
    adjacent_points <- c(adjacent_points, dat[row, column + 1]) # right
  if (i != nrow(dat))
    adjacent_points <- c(adjacent_points, dat[row + 1, column]) # below
  if (j != 1)
    adjacent_points <- c(adjacent_points, dat[row, column - 1]) # left
  # Compare height to adjacent heights
  if (all(height < adjacent_points)) 
    return(data.frame(x = row, y = column, risk = height + 1))
}

# Find all of the low points on the heightmap and calculate risk level
lowest_points <- data.frame(x = numeric(), y = numeric(), risk = numeric())
for (i in seq_len(nrow(dat))) {
  for (j in seq_len(ncol(dat))) {
    lowest_point <- compare_heights(dat, i, j)
    lowest_points <- rbind.data.frame(lowest_points, lowest_point)
  }
}

# What is the sum of the risk levels of all low points on your heightmap?
sum(lowest_points$risk)
```

### Part 2

```{r day9-2}
# Check height is less than 9
check_height <- function(dat, row, column) {
  if (dat[row, column] < 9) 
    return(data.frame(row = row, column = column, height = dat[row, column]))
}

# Return neighbouring points that have a height less than 9
check_adjacent <- function(dat, row, column) {
  # Find height of adjacent points
  adjacent_points <- data.frame(row = numeric(), column = numeric(), 
                                height = numeric())
  # Above
  if (row != 1) 
    adjacent_points <- rbind(adjacent_points, check_height(dat, row - 1, column))
  # Right
  if (column != ncol(dat)) 
    adjacent_points <- rbind(adjacent_points, check_height(dat, row, column + 1))
  # Below
  if (row != nrow(dat)) 
    adjacent_points <- rbind(adjacent_points, check_height(dat, row + 1, column))
  # Left
  if (column != 1) 
    adjacent_points <- rbind(adjacent_points, check_height(dat, row, column - 1))
  
  # Return neibouring points that should be checked
  adjacent_points %>% 
    dplyr::filter(height != 9)
}

# For a particular `lowest_point`, survey the basin and return it's size
survey <- function(dat, row, column) {
  # Height of lowest point being surveyed
  height <- dat[row, column]
  # Initialise basin dataframe
  basin <- data.frame(row = row, column = column, risk = height + 1)
  # Find adjacent points with depth less than 9 
  neighbours <- check_adjacent(dat, row, column)
  # Add them to the basin
  tmp <- neighbours %>% 
    dplyr::mutate(risk = height + 1) %>% 
    dplyr::select(-height)
  basin <- rbind(basin, tmp)
  
  # Check neighbouring points
  continue <- nrow(neighbours) > 0
  while(continue) {
    more_neighbours <- check_adjacent(dat, 
                                      neighbours$row[1], 
                                      neighbours$column[1])
    # Remove this point from `neighbours`
    neighbours <- neighbours[-1, ]
    # Remove new neighbours that are already in the basin
    more_neighbours <- setdiff(dplyr::select(more_neighbours, -height), 
                               dplyr::select(basin, -risk)) %>% 
      dplyr::left_join(more_neighbours, by = c("row", "column"))
    
    # If any new neighbours are remaining
    if (nrow(more_neighbours) > 0) {
      # Add them to the basin
      tmp <- more_neighbours %>% 
        dplyr::mutate(risk = height + 1) %>% 
        dplyr::select(-height)
      basin <- rbind(basin, tmp)
      # And add them to `neighbours` (for checking)
      neighbours <- rbind(neighbours, more_neighbours)
    }
    
    continue <- nrow(neighbours) > 0
  }
  # Return size of basin
  nrow(basin)
}

# Find all of the low points on the heightmap and calculate basin size
results <- c()
for (i in seq_len(nrow(lowest_points))) {
  # cat("\r", i, "/", nrow(lowest_points))
  size <- survey(dat, lowest_points$x[i], lowest_points$y[i])
  results <- c(results, size)
}

# Multiply together the sizes of the three largest basins
prod(tail(sort(results), 3))
```

## Day 10: Syntax Scoring

Link to questions [here](https://adventofcode.com/2021/day/10)

### Part 1

```{r day10-1}
# Read in data
dat <- readLines(file.path(here(), "inst", "2021", "day10.txt")) 

corrupted_score <- function(character) {
  score_table <- data.frame(char = c(")", "]", "}", ">"), 
                            val = c(3, 57, 1197, 25137))
  score_table$val[which(score_table$char == character)]
}

total <- 0
remove_lines <- c()

for (i in seq_along(dat)){
  expecting <- c()
  points <- NA
  check_this <- strsplit(dat[i], "")[[1]]
  
  for (j in seq_along(check_this)) {
    if (check_this[j] == "("){
      expecting <- c(expecting, ")")
      
    } else if (check_this[j] == "[") {
      expecting <- c(expecting, "]")
      
    } else if (check_this[j] == "{") {
      expecting <- c(expecting, "}")
      
    } else if (check_this[j] == "<") {
      expecting <- c(expecting, ">")
      
    } else {
      # If `check_this` matches the last expected value, remove it 
      if (check_this[j] == tail(expecting, 1)) {
        expecting <- expecting[-length(expecting)]
        
      } else if (is.na(points)) {
        # Otherwise add the score to `total`
        points <- corrupted_score(check_this[j])
        total <- total + points
        remove_lines <- c(remove_lines, i)
        break
      }
    }
  }
}

# Find the first illegal character in each corrupted line of the navigation 
# subsystem. What is the total syntax error score for those errors?
total
```

### Part 2

```{r day10-2}
# Remove corrupted lines
incomplete_lines <- dat[-remove_lines]

incomplete_score <- function(character) {
  score_table <- data.frame(char = c(")", "]", "}", ">"), 
                            val = c(1, 2, 3, 4))
  score_table$val[which(score_table$char == character)]
}

results <- c()
for (i in seq_along(incomplete_lines)){
  expecting <- c()
  check_this <- strsplit(incomplete_lines[i], "")[[1]]
  points <- 0
  
  for (j in seq_along(check_this)) {
    if (check_this[j] == "("){
      expecting <- c(expecting, ")")
      
    } else if (check_this[j] == "[") {
      expecting <- c(expecting, "]")
      
    } else if (check_this[j] == "{") {
      expecting <- c(expecting, "}")
      
    } else if (check_this[j] == "<") {
      expecting <- c(expecting, ">")
    } else {
      # If `check_this` matches the last expected value, remove it 
      if (check_this[j] == tail(expecting, 1)) {
        expecting <- expecting[-length(expecting)]
      }
    }
  }
  expecting <- rev(expecting)
  
  # Calculate score
  for (k in seq_along(expecting)) {
    points <- (points * 5) + incomplete_score(expecting[k])
  }
  results <- c(results, points)
  
}

# Find the completion string for each incomplete line, score the completion 
# strings, and sort the scores. What is the middle score?
index <- ceiling(length(results) / 2)
value <- sort(results)[index]
format(value, scientific = FALSE)
```

## Day 11: Dumbo Octopus

Link to questions [here](https://adventofcode.com/2021/day/11)

### Part 1

```{r day11-1}
# Read in data
dat <- scan(file.path(here(), "inst", "2021", "day11.txt"), 
            what = "character") %>% 
  strsplit("") %>% 
  do.call(rbind, .) %>% 
  apply(1, as.numeric)

find_neighbours <- function(x, y, flashing_now, flashed_previously, octopus) {
  # Index neighbours
  tmp <- rbind(data.frame(row = x - 1, col = (y - 1):(y + 1)), # above
               data.frame(row = x, col = c(y - 1, y + 1)),     # sides
               data.frame(row = x + 1, col = (y - 1):(y + 1))) # below
  # Remove invalid coordinates
  xlim <- ncol(octopus) + 1
  ylim <- nrow(octopus) + 1
  tmp <- dplyr::filter(tmp, row != 0, col != 0, row != xlim, col != ylim)
  # Add to `neighbours`, remove duplicates, and remove those that are flashing 
  # now or have flashed previously
  tmp %>% 
    unique() %>% 
    anti_join(data.frame(flashing_now), by = c("row", "col")) %>% 
    anti_join(data.frame(flashed_previously), by = c("row", "col")) %>% 
    as.matrix()
}

timestep <- function(octopus) {
  # Increases the energy level of each octopus by 1
  octopus <- octopus + 1
  done <- matrix(nrow = 0, ncol = 2)
  
  # Any octopus with an energy level greater than 9 flashes and has its energy 
  # level reset to 0, the energy level of all adjacent octopuses (including 
  # octopuses that are diagonally adjacent) increases by 1. If this causes an 
  # octopus to have an energy level greater than 9, it also flashes
  while (any(octopus > 9)) {
    # Check if energy level is greater than 9 
    flash <- which(octopus > 9, arr.ind = T)
    # Flash
    done <- rbind(done, flash)
    # Reset energy
    octopus[flash] <- 0
    
    # For each flashing octopus
    for (j in seq_len(nrow(flash))) {
      x <- unname(flash[j, "row"])
      y <- unname(flash[j, "col"])
      # Find adjacent octopi
      neighbours <- find_neighbours(x, y, flash, done, octopus)
      # Increase energy level by 1
      octopus[neighbours] <- octopus[neighbours] + 1
    } 
  }
  # Latest flashes
  list(octopus = octopus, latest_flashes = nrow(done))
}

octopus <- dat
count <- 0

# Given the starting energy levels of the dumbo octopuses in your cavern, 
# simulate 100 steps. 
for (i in 1:100) {
  # cat("\r", i, "of 100")
  data <- timestep(octopus)
  octopus <- data$octopus
  count <- count + data$latest_flashes
}

# How many total flashes are there after 100 steps?
count
```

### Part 2

```{r day11-2}
octopus <- dat
count <- 1

# What is the first step during which all octopuses flash?
while (sum(octopus) != 0) {
  # cat("\r", count)
  data <- timestep(octopus)
  octopus <- data$octopus
  count <- count + 1
}

count
```
