[{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2019.html","id":"part-1","dir":"Articles","previous_headings":"Day 1: The Tyranny of the Rocket Equation","what":"Part 1","title":"AoC 2019 (Python)","text":"","code":"grid = np.random.rand(5,2) df = pd.DataFrame(grid)  def multiply(x):     return x[0]*x[1]  df['multiply'] = df.apply(multiply, axis = 1) print(df) ##           0         1  multiply ## 0  0.649490  0.337078  0.218929 ## 1  0.253530  0.422294  0.107064 ## 2  0.057922  0.795811  0.046095 ## 3  0.316150  0.987584  0.312225 ## 4  0.595317  0.561427  0.334227"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-R.html","id":"part-1","dir":"Articles","previous_headings":"Day 12: Day 12: Rain Risk","what":"Part 1","title":"AoC 2020 (R)","text":"","code":"# Read in data ------------------------------------------------------------  day12input <- function(path) {   readLines(path) |>     data.frame() |>     setNames(\"dat\") |>     tidyr::separate(\"dat\", into = c(\"inst\", \"value\"),                     sep = \"(?<=[A-Za-z])(?=[0-9])\") |>     dplyr::mutate(value = as.numeric(value)) }  test <- here(\"inst\", \"2020\", \"day12-test.txt\") |>   day12input()  dat <- here(\"inst\", \"2020\", \"day12.txt\") |>   day12input()  # Define functions --------------------------------------------------------  evasive_actions <- R6::R6Class(\"ferry\", list(   ship = NULL,   rot = NULL,    initialize = function() {     self$ship <- c(0, 0)     self$rot <- 90     invisible(self)   },    print = function(...) {     cat(\"ship:\", self$ship, \"/n\")     invisible(self)   },    move = function(inst, value) {     switch(inst,            \"N\" = {self$ship[2] <- self$ship[2] + value},            \"S\" = {self$ship[2] <- self$ship[2] - value},            \"E\" = {self$ship[1] <- self$ship[1] + value},            \"W\" = {self$ship[1] <- self$ship[1] - value},            \"L\" = {tmp <- self$rot - value            self$rot <- ifelse(tmp < 0, 360 + tmp, tmp)},            \"R\" = {tmp <- self$rot + value            self$rot <- ifelse(tmp >= 360, tmp - 360, tmp)},            \"F\" = self$forward(value))     invisible(self)   },    forward = function(value) {     if (self$rot == 0) {       self$move(\"N\", value)     } else if (self$rot == 90) {       self$move(\"E\", value)     } else if (self$rot == 180) {       self$move(\"S\", value)     } else if (self$rot == 270) {       self$move(\"W\", value)     }     invisible(self)   } ))  evade <- function(dat) {   ferry <- evasive_actions$new()    # Perform evasive action   for (i in seq_len(nrow(dat))) {     ferry$move(dat$inst[i], dat$value[i])   }    # Calculate Manhattan distance   rbind(c(0, 0), ferry$ship) |>     dist(method = \"manhattan\") |>     c() }  # Take evasive actions ----------------------------------------------------  assertthat::assert_that(evade(test) == 25) ## [1] TRUE # What is the Manhattan distance between that location and the ship's # starting position?  evade(dat) ## [1] 2270"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1","dir":"Articles","previous_headings":"Day 1: Report Repair","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data path = joinpath(\"..\", \"inst\", \"2020\", \"day1.txt\") ## \"../inst/2020/day1.txt\" dat = vec(readdlm(path));  # Find the two entries that sum to 2020 numbers = [x for x in combinations(dat, 2) if sum(x) == 2020];  # Convert 1-element Vector{Vector{Float64}} to 2-element Vector{Float64} numbers = reshape(numbers)[1];  # What do you get if you multiply them together? prod(Int, numbers) ## 802011"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"notes","dir":"Articles","previous_headings":"Day 1: Report Repair > Part 1","what":"Notes","title":"AoC 2020 (Julia)","text":"Array comprehension following syntax:","code":"[x^2 for x = 1:3] ## 3-element Vector{Int64}: ##  1 ##  4 ##  9"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2","dir":"Articles","previous_headings":"Day 1: Report Repair","what":"Part 2","title":"AoC 2020 (Julia)","text":"","code":"# What is the product of the three entries that sum to 2020? numbers = [x for x in combinations(dat, 3) if sum(x) == 2020]; numbers = reshape(numbers)[1]; res = prod(Int, numbers) ## 248607374"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"notes-1","dir":"Articles","previous_headings":"Day 1: Report Repair > Part 2","what":"Notes","title":"AoC 2020 (Julia)","text":"Conditional comprehension following syntax:","code":"[x^2 for x = 1:3 if x > 1] ## 2-element Vector{Int64}: ##  4 ##  9"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-1","dir":"Articles","previous_headings":"Day 2: Password Philosophy","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data path = joinpath(\"..\", \"inst\", \"2020\", \"day2.txt\"); dat = readlines(path);  function sled_password_check(dat)      results = 0          for i in dat         m = match(r\"(\\d+)-(\\d+)\\s+(.):\\s+(.+)\", i)  # grep         minimum = parse(Int64, m.captures[1])       # convert to Int64         maximum = parse(Int64, m.captures[2])         letter = m.captures[3]         password = m.captures[4]         n = count(letter, password)         results += (n >= minimum && n <= maximum) ? 1 : 0     end          results  end;  # How many passwords are valid according to their policies? sled_password_check(dat) ## 640"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"notes-2","dir":"Articles","previous_headings":"Day 2: Password Philosophy > Part 1","what":"Notes","title":"AoC 2020 (Julia)","text":"ternary operator, ?: related -elseif-else syntax written condition ? value_if_true : value_if_false. Julia complains scoping issues calling results += 1inside aforloop (ifresultswas defined outside ). Rather usingglobal results += 1`, putting everything function achieve expected behaviour.","code":""},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2-1","dir":"Articles","previous_headings":"Day 2: Password Philosophy","what":"Part 2","title":"AoC 2020 (Julia)","text":"","code":"function toboggan_password_check(dat)          results = 0      for i in dat         m = match(r\"(\\d+)-(\\d+)\\s+(.):\\s+(.+)\", i)  # grep         pos1 = parse(Int64, m.captures[1])          # convert to Int64         pos2 = parse(Int64, m.captures[2])         letter = only(m.captures[3])                # convert to ASCII/Unicode         password = m.captures[4]          # Exactly one of these positions must contain the given letter         test = (password[pos1] == letter) + (password[pos2] == letter) == 1         results += test ? 1 : 0     end      results      end;  # How many passwords are valid according to the new interpretation of the policies? toboggan_password_check(dat) ## 472"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-2","dir":"Articles","previous_headings":"Day 3: Toboggan Trajectory","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data path = joinpath(\"..\", \"inst\", \"2020\", \"day3.txt\"); dat = readlines(path);  function trees(x, y, map)      xpos = ypos = 1     results = 0     xlim = length(map[1])     ylim = length(map)          while ypos != ylim         xpos += x         xpos = (xpos > xlim) ? xpos - xlim : xpos         ypos += y         results += map[ypos][xpos] == only(\"#\") ? 1 : 0     end      results      end;  # Starting at the top-left corner of your map and following a slope of right 3 and  # down 1, how many trees would you encounter? trees(3, 1, dat) ## 237"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2-2","dir":"Articles","previous_headings":"Day 3: Toboggan Trajectory","what":"Part 2","title":"AoC 2020 (Julia)","text":"","code":"# Determine the number of trees you would encounter if, for each of the following  # slopes, you start at the top-left corner and traverse the map all the way to the  # bottom iterate = [[1,1], [3,1], [5,1], [7,1], [1,2]]; results = [trees(iterate[x][1], iterate[x][2], dat) for x in eachindex(iterate)];  # What do you get if you multiply together the number of trees encountered on each of   # the listed slopes? prod(results) ## 2106818610"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-3","dir":"Articles","previous_headings":"Day 4: Passport Processing","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data path = joinpath(\"..\", \"inst\", \"2020\", \"day4.txt\"); dat = readlines(path);  function parsepassports(dat)       record = []     d = Dict{String, String}()          for i in eachindex(dat)          if isempty(dat[i])             push!(record, d)             d = Dict{String, String}()         else             for j in split(dat[i])                 key, value = split(j, \":\")                 d[key] = value             end             i == length(dat) ? push!(record, d) : nothing         end      end      record  end;  function countpassports(passports)      counter = 0     fields = [\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\"]          for i in eachindex(passports)         invalid = sum([!haskey(passports[i], key) for key in fields]) > 0         counter += invalid ? 0 : 1     end          counter  end;  # How many passports are valid? passports = parsepassports(dat); countpassports(passports) ## 182"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2-3","dir":"Articles","previous_headings":"Day 4: Passport Processing","what":"Part 2","title":"AoC 2020 (Julia)","text":"","code":"function checkfields(passports)      fields = [\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\"]     colours = [\"amb\", \"blu\", \"brn\", \"gry\", \"grn\", \"hzl\", \"oth\"]     counter = 0          for i in passports          invalid = sum([!haskey(i, key) for key in fields]) > 0          if (!invalid)             byr = 1920 <= parse(Int, i[\"byr\"]) <= 2002             iyr = 2010 <= parse(Int, i[\"iyr\"]) <= 2020             eyr = 2020 <= parse(Int, i[\"eyr\"]) <= 2030                  if endswith(i[\"hgt\"], \"cm\")                 tmp = parse(Int, replace(i[\"hgt\"], \"cm\" => \"\"))                 hgt = 150 <= tmp <= 193             elseif endswith(i[\"hgt\"], \"in\")                 tmp = parse(Int, replace(i[\"hgt\"], \"in\" => \"\"))                 hgt = 59 <= tmp <= 76             else                  hgt = false             end                  hcl = match(r\"^#[0-9a-f]{6}\", i[\"hcl\"]) != nothing             ecl = issubset([i[\"ecl\"]], colours)             pid = match(r\"^[0-9]{9}$\", i[\"pid\"]) != nothing                          # Is passport valid?             test = byr & iyr & eyr & hgt & hcl & ecl & pid             counter += test ? 1 : 0         end              end      counter  end;  # How many passports are valid? checkfields(passports) ## 109"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-4","dir":"Articles","previous_headings":"Day 5: Binary Boarding","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data path = joinpath(\"..\", \"inst\", \"2020\", \"day5.txt\"); dat = readlines(path);  function findseat(dat)         output = []      for i in eachindex(dat)                  row_min, row_max = 0, 127         col_min, col_max = 0, 7          # Get row         row_directions = dat[i][1:7]         for j in row_directions             if j == only(\"F\")                 row_max = floor(Int, row_max - (row_max - row_min) / 2)             elseif j == only(\"B\")                 row_min = ceil(Int, row_min + (row_max - row_min) / 2)             end         end          # Get column         seat = dat[i][8:10]         for j in seat             if j == only(\"L\")                 col_max = floor(Int, col_max - (col_max - col_min) / 2)             elseif j == only(\"R\")                 col_min = ceil(Int, col_min + (col_max - col_min) / 2)             end         end      # Calculate seat ID     seat_id = (row_min * 8) + col_max     push!(output, seat_id)     end      output end;  # Try test data test = readlines(joinpath(\"..\", \"inst\", \"2020\", \"day5-test.txt\")); @assert all(findseat(test) .== [357, 567, 119, 820])  # What is the highest seat ID on a boarding pass? seat_ids = findseat(dat); maximum(seat_ids) ## 906"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2-4","dir":"Articles","previous_headings":"Day 5: Binary Boarding","what":"Part 2","title":"AoC 2020 (Julia)","text":"\\\\notin, TAB:","code":"# What is the ID of your seat?  seats = sort(seat_ids);  myseat = function(seats)     for i in 1:maximum(seats)         if i ∉ seats && i-1 ∈ seats && i+1 ∈ seats             return(i)         end     end end;  myseat(seats) ## 519"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-5","dir":"Articles","previous_headings":"Day 6: Custom Customs","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data path = joinpath(\"..\", \"inst\", \"2020\", \"day6-test.txt\"); raw = read(path, String);  groups = split(raw, \"\\n\\n\");          # split into groups ## 5-element Vector{SubString{String}}: ##  \"abc\" ##  \"a\\nb\\nc\" ##  \"ab\\nac\" ##  \"a\\na\\na\\na\" ##  \"b\\n\" dat = replace.(groups, \"\\n\" => \"\");   # remove line breaks ## 5-element Vector{String}: ##  \"abc\" ##  \"abc\" ##  \"abac\" ##  \"aaaa\" ##  \"b\" # For each group, count the number of questions to which anyone answered \"yes\" length.(unique.(dat));  # What is the sum of those counts? sum(length.(unique.(dat))) ## 11"},{"path":[]},{"path":[]},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-7","dir":"Articles","previous_headings":"Day 8: Handheld Halting","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data ------------------------------------------------------------  path = joinpath(\"..\", \"inst\", \"2020\", \"day8.txt\"); dat = read(path, String);  # Define functions --------------------------------------------------------  function tidyday8(dat)     dat = split(dat, \"\\n\")                      # split by new line     dat = filter(!isempty, dat)                 # remove empty last element     dat = split.(dat, \" \")                      # split by space      # Tidy up data     inst = [x[1] for x in dat]                  # extract instructions     val = [x[2] for x in dat]                   # extract values      vals = map(val) do str     mat = match.(r\"[\\+|\\-](\\d*)\", str)          # regex to extract number     cap = mat.captures                          # extract capture group     num = parse(Int64, cap[1])                  # convert string to number     contains.(str, \"-\") ? num * -1 : num        # multiply by -1 if negative     end      inst, vals end;  function boot(inst, vals)     accumulator = 0;                            # initialise accumulator     i = 1;                                      # initialise place in instruction list     log = [];      while i ∉ log                               # stop before an instruction is run again         push!(log, i)                           # record i in log          if inst[i] == \"acc\"             accumulator += vals[i]              # add value to accumulator             i += 1                              # next instruction         elseif inst[i] == \"jmp\"             i += vals[i]                        # jump to a new instruction         elseif inst[i] == \"nop\"             i += 1                              # next instruction         end     end     return(accumulator) end;  # Run boot code ----------------------------------------------------------  inst, vals = tidyday8(dat);  # Immediately before any instruction is executed a second time, what value is in the  # accumulator? boot(inst, vals) ## 1749"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2-5","dir":"Articles","previous_headings":"Day 8: Handheld Halting","what":"Part 2","title":"AoC 2020 (Julia)","text":"","code":"# Run boot code ----------------------------------------------------------  function boot2(inst, vals)      stop_condition = length(inst) + 1      for i in 1:length(inst)          new_inst = copy(inst)              if inst[i] == \"acc\"             continue         elseif inst[i] == \"jmp\"             new_inst[i] = \"nop\"         elseif inst[i] == \"nop\"             new_inst[i] = \"jmp\"         end                  accumulator = 0                         # initialise accumulator         j = 1                                   # initialise place in instruction list         log = []                   while j ∉ log                           # stop before an instruction is run again             if j == stop_condition              # found correct termination point!                 return(accumulator)               end             push!(log, j)                       # record i in log                  if new_inst[j] == \"acc\"                 accumulator += vals[j]          # add value to accumulator                 j += 1                          # next instruction             elseif new_inst[j] == \"jmp\"                 j += vals[j]                    # jump to a new instruction             elseif new_inst[j] == \"nop\"                 j += 1                          # next instruction             end         end     end end;  boot2(inst, vals) ## 515"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-8","dir":"Articles","previous_headings":"Day 9: Encoding Error","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"# Read in data ------------------------------------------------------------  path = joinpath(\"..\", \"inst\", \"2020\", \"day9.txt\"); dat = readlines(path);                        # Define functions --------------------------------------------------------  function day11(dat)     # convert string to numeric     parse.(Int64, dat) end;  function checksums(dat)     preamble = 25      # generate pairwise combination index     cmb = combinations(1:preamble, 2) |> collect         # find sum of each pairwise combination     add = map(x -> dat[x[1]] + dat[x[2]], cmb)                for i in eachindex(dat)         # don't check preamble         if i ∈ 1:preamble                                        continue         end              # remove elements outwith the preamble          tmp = i - preamble - 1                                  remove = findall(x -> x[1] == tmp || x[2] == tmp, cmb)         deleteat!(cmb, remove)         deleteat!(add, remove)          # generate next set of indices         tmp = (tmp + 1):(i - 1)                              ind = map(x -> [i, x], tmp)                          append!(cmb, ind)              # generate next set of additions              new = map(x -> dat[x[1]] + dat[x[2]], ind)                     append!(add, new)          # return invalid number         if dat[i] ∉ add                                          return(dat[i])         end      end end;  # Find the first number in the list (after the preamble) which is not the sum of  # two of the 25 numbers before it  # What is the first number that does not have this property?  dat = day11(dat) ## 1000-element Vector{Int64}: ##                3 ##               17 ##               32 ##                2 ##               19 ##               45 ##               22 ##               18 ##               38 ##                8 ##                ⋮ ##   92412361470618 ##   93964358367387 ##   94334470603341 ##  123814366611218 ##  110087627226740 ##   98650943515733 ##  104829897365462 ##  104882565934705 ##  108297043768811 invalid = checksums(dat) ## 257342611"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-2-6","dir":"Articles","previous_headings":"Day 9: Encoding Error","what":"Part 2","title":"AoC 2020 (Julia)","text":"","code":"# Find a contiguous set of at least two numbers in your list which sum to the  # invalid number from step 1  function findweakness(dat, invalid)     for i in eachindex(dat)          total = dat[i]         j = i              while(total < invalid)             j += 1             total += dat[j]         end              if total == invalid             # Find encryption weakness             vals = dat[i:j]                                      weakness = minimum(vals) + maximum(vals)             return(weakness)         end          end end;  findweakness(dat, invalid) ## 35602097"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2020-julia.html","id":"part-1-9","dir":"Articles","previous_headings":"Day 10: Adapter Array","what":"Part 1","title":"AoC 2020 (Julia)","text":"","code":"path = joinpath(\"..\", \"inst\", \"2020\", \"day10.txt\");  # Find a chain that uses all of your adapters to connect the charging outlet to your  # device's built-in adapter and count the joltage differences between the charging  # outlet, the adapters, and your device  function day10(path)     dat = readlines(path)                           # read data     dat = parse.(Int64, dat)                        # convert string to integer end;  function part1(dat)     tmp = copy(dat) |> sort                         # sort values     whole = vcat(0, tmp, tmp[end] + 3)              # prepend with 0, append with +3     ones = count(==(1), diff(sort(whole)))          # count number of ones     threes = count(==(3), diff(sort(whole)))        # count number of threes     ones * threes end;  # What is the number of 1-jolt differences multiplied by the number of 3-jolt  # differences? day10(path) |> part1 ## 2450"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1","dir":"Articles","previous_headings":"Day 1: Sonar Sweep","what":"Part 1","title":"AoC 2021 (R)","text":"0.014 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day1.txt\") |>   scan()  # Count the number of times the depth increases from the previous measurement sum(diff(dat) > 0) ## [1] 1832"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2","dir":"Articles","previous_headings":"Day 1: Sonar Sweep","what":"Part 2","title":"AoC 2021 (R)","text":"0.029 sec.","code":"# Sum depths in each window index <- 1 summed <- c() while((index + 2) <= length(dat)) {   summed <- c(summed, sum(dat[index:(index + 2)]))   index <- index + 1 }  # Count the number of times the depth increases from the previous measurement sum(diff(summed) > 0) ## [1] 1858"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-1","dir":"Articles","previous_headings":"Day 2: Dive!","what":"Part 1","title":"AoC 2021 (R)","text":"0.037 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day2.txt\") |>   read.table() |>   setNames(c(\"direction\", \"value\"))  # Calculate the horizontal position and depth and multiply them together summarise_dat <- dat |>   dplyr::group_by(direction) |>   dplyr::summarise(total = sum(value))  horizontal_position <- summarise_dat$total[summarise_dat$direction == \"forward\"] depth <- summarise_dat$total[summarise_dat$direction == \"down\"] -   summarise_dat$total[summarise_dat$direction == \"up\"]  horizontal_position * depth ## [1] 1648020"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-1","dir":"Articles","previous_headings":"Day 2: Dive!","what":"Part 2","title":"AoC 2021 (R)","text":"0.023 sec.","code":"# Initialise variables aim <- 0 horizontal_position <- 0 depth <- 0  # Track aim for (i in seq_len(nrow(dat))) {   if (dat$direction[i] == \"down\") {     aim <- aim  + dat$value[i]   } else if (dat$direction[i] == \"up\") {     aim <- aim  - dat$value[i]   } else {     horizontal_position <- horizontal_position + dat$value[i]     depth <- depth + (aim * dat$value[i])   } }  horizontal_position * depth ## [1] 1759818555"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-2","dir":"Articles","previous_headings":"Day 3: Binary Diagnostic","what":"Part 1","title":"AoC 2021 (R)","text":"0.056 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day3.txt\") |>   scan(what = \"character\")  # Number of bits in each binary number digits <- nchar(dat[1])  # Calculate gamma and epsilon rates gamma_binary <- rep(NA, digits) epsilon_binary <- rep(NA, digits)  for (i in seq_len(digits)) {   # Extract the i[th] character of each string   character <- vapply(dat, function(x) substr(x, i, i), character(1))   # Find most common bit   zeroes <- sum(character == \"0\")   ones <- sum(character == \"1\")   gamma_binary[i] <- dplyr::if_else(zeroes > ones, 0, 1)   epsilon_binary[i] <- dplyr::if_else(zeroes < ones, 0, 1) }  gamma_rate <- strtoi(paste(gamma_binary, collapse = \"\"), base = 2) epsilon_rate <- strtoi(paste(epsilon_binary, collapse = \"\"), base = 2)  # Calculate power consumption gamma_rate * epsilon_rate ## [1] 2954600"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-2","dir":"Articles","previous_headings":"Day 3: Binary Diagnostic","what":"Part 2","title":"AoC 2021 (R)","text":"0.044 sec.","code":"# Define functions --------------------------------------------------------  rating <- function(dat, type) {   # For each bit in a binary string   for (i in seq_len(digits)) {     # Extract the i[th] character of each string     character <- vapply(dat, function(x) substr(x, i, i),                         character(1))     # Find zeroes and ones     zeroes <- character == \"0\"     ones <- character == \"1\"     # Find most common bit     if (sum(zeroes) > sum(ones)) {       bit_criteria <- which(zeroes)     } else if (sum(zeroes) < sum(ones)) {       bit_criteria <- which(ones)     } else {       bit_criteria <- which(ones)     }     # Keep binary strings with most common bit in the ith position     if (type == \"oxygen\") {       dat <- dat[bit_criteria]     } else if (type == \"CO2\") {       dat <- dat[-bit_criteria]     }     # If there's only one binary string left, stop     if (length(dat) == 1) break   }   # Return decimal   strtoi(paste(dat, collapse = \"\"), base = 2) }  # Run simulation ----------------------------------------------------------  # Calculate oxygen generator and CO2 scrubber ratings oxygen_generator_rating <- rating(dat, \"oxygen\") CO2_scrubber_rating <- rating(dat, \"CO2\")  # Calculate life support rating oxygen_generator_rating * CO2_scrubber_rating ## [1] 1662846"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-3","dir":"Articles","previous_headings":"Day 4: Giant Squid","what":"Part 1","title":"AoC 2021 (R)","text":"0.507 sec.","code":"# Read in data ------------------------------------------------------------ path <- here(\"inst\", \"2021\", \"day4.txt\")  numbers <- scan(path, what = \"character\", n = 1) |>   strsplit(\",\") |>   unlist() |>   as.numeric()  raw_boards <- read.table(path, skip = 1) number_of_boards <- nrow(raw_boards) / 5  boards <- lapply(seq_len(number_of_boards), function(x) {   start <- 1 + (5 * (x - 1))   end <- start + 4   raw_boards[start:end, ] })  # Define functions --------------------------------------------------------  update_board <- function(number, board) {   check_number <- board == number   if (any(check_number, na.rm = TRUE)) {     # Mark the number     find_number <- which(check_number, arr.ind = TRUE)     board[find_number] <- NA   }   board }  check_for_win <- function(board) {   check_board <- is.na(board)   row_win <- any(rowSums(check_board) == 5)   column_win <- any(colSums(check_board) == 5)   if_else(row_win | column_win, TRUE, FALSE) }  play_bingo <- function(numbers, boards) {   # For each number in the bingo call   for (this_number in numbers) {     # Check each board     for (i in seq_along(boards)) {       # If the number is on the board, mark it off (as NA)       boards[[i]] <- update_board(this_number, boards[[i]])       # Check for win       has_won <- check_for_win(boards[[i]])       # If this board has won, calculate the winning score       if (has_won)         return(sum(boards[[i]], na.rm = TRUE) * this_number)     }   } }  # Play bingo --------------------------------------------------------------  play_bingo(numbers, boards) ## [1] 31424"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-3","dir":"Articles","previous_headings":"Day 4: Giant Squid","what":"Part 2","title":"AoC 2021 (R)","text":"1.301 sec.","code":"lose_bingo <- function(numbers, boards) {   # Initialise objects   results <- data.frame(number = numeric(), board = numeric(), score = numeric())   remaining_boards <- seq_along(boards)    # For each number in the bingo call   for (this_number in numbers) {     # Check each board     for (i in remaining_boards) {       # If the number is on the board, mark it off (as NA)       boards[[i]] <- update_board(this_number, boards[[i]])       # Check for win       has_won <- check_for_win(boards[[i]])       # If this board has won, calculate the winning score       if (has_won) {         score <- sum(boards[[i]], na.rm = TRUE) * this_number         results <- rbind(results,                          data.frame(number = this_number,                                     board = i,                                     score = score))         remaining_boards <- remaining_boards[-which(remaining_boards == i)]       }     }   }   results }  # Play bingo losers <- lose_bingo(numbers, boards) tail(losers) ##     number board score ## 95      43    70 14835 ## 96      41    76 11767 ## 97       9    15  4599 ## 98       9    82  3726 ## 99      84    89 36120 ## 100     82    16 23042"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-4","dir":"Articles","previous_headings":"Day 5: Hydrothermal Venture","what":"Part 1","title":"AoC 2021 (R)","text":"0.106 sec.","code":"# Read in data coordinates <- here(\"inst\", \"2021\", \"day5.txt\") |>   read.table() |>   dplyr::select(-V2) |>   tidyr::separate(V1, c(\"x1\", \"y1\")) |>   tidyr::separate(V3, c(\"x2\", \"y2\")) |>   dplyr::mutate(dplyr::across(dplyr::everything(), as.numeric))  # Initialise object xlim <- max(c(coordinates$x1, coordinates$x2)) ylim <- max(c(coordinates$y1, coordinates$y2)) grid <- matrix(0, nrow = ylim, ncol = xlim)  # Track horizontal and vertical lines for (i in seq_len(nrow(coordinates))) {   this_line <- coordinates[i, ]    if (this_line$x1 == this_line$x2) {     # Horizontal line     this_x <- this_line$x1     y_values <- this_line$y1:this_line$y2     # Add one to each point on the line     for (y in y_values) grid[this_x, y] <- grid[this_x, y] + 1    } else if (this_line$y1 == this_line$y2) {     # Vertical line     this_y <- this_line$y1     x_values <- this_line$x1:this_line$x2     # Add one to each point on the line     for (x in x_values) grid[x, this_y] <- grid[x, this_y] + 1   } }  # Find points where at least two lines overlap sum(grid >= 2) ## [1] 6572"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-4","dir":"Articles","previous_headings":"Day 5: Hydrothermal Venture","what":"Part 2","title":"AoC 2021 (R)","text":"0.109 sec.","code":"# Initialise object grid <- matrix(0, nrow = ylim, ncol = xlim)  # Track horizontal, vertical lines, and diagonal lines for (i in seq_len(nrow(coordinates))) {   this_line <- coordinates[i, ]    if (this_line$x1 == this_line$x2) {     # Horizontal line     this_x <- this_line$x1     y_values <- this_line$y1:this_line$y2     # Add one to each point on the line     for (y in y_values) grid[this_x, y] <- grid[this_x, y] + 1    } else if (this_line$y1 == this_line$y2) {     # Vertical line     this_y <- this_line$y1     x_values <- this_line$x1:this_line$x2     # Add one to each point on the line     for (x in x_values) grid[x, this_y] <- grid[x, this_y] + 1    } else if(abs(this_line$x1 - this_line$x2) == abs(this_line$y1 - this_line$y2)) {     # Diagonal line     x_values <- this_line$x1:this_line$x2     y_values <- this_line$y1:this_line$y2     # Add one to each point on the line     for (i in seq_along(x_values))       grid[x_values[i], y_values[i]] <- grid[x_values[i], y_values[i]] + 1   } }  # Find points where at least two lines overlap sum(grid >= 2) ## [1] 21466"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-5","dir":"Articles","previous_headings":"Day 6: Lanternfish","what":"Part 1","title":"AoC 2021 (R)","text":"0.075 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day6.txt\") |>   scan(what = \"character\", sep = \",\") |>   as.numeric()  # Initialise variables days <- 80 fish <- dat  # Simulate lanternfish for (i in seq_len(days)) {   # Find zeroes   zeroes <- which(fish == 0)   # Subtract 1 from all fish   fish <- fish - 1   # Reset zeroes to six   fish[zeroes] <- 6   # Add eights for each zero   fish <- c(fish, rep(8, length(zeroes))) }  # How many lanternfish would there be after 80 days? length(fish) ## [1] 390923"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-5","dir":"Articles","previous_headings":"Day 6: Lanternfish","what":"Part 2","title":"AoC 2021 (R)","text":"takes much memory simulate individual fish vector, generate frequency table instead. 0.087 sec.","code":"# Initialise variables days <- 256  # Generate a frequency table fish_counts <- data.frame(age = dat) |>   dplyr::count(age) |>                     # Count fish   complete(age = 0:8, fill = list(n = 0))  # Fill in the missing categories  for (i in seq_len(days)) {   # Number of zeroes   n_zeroes <- fish_counts$n[fish_counts$age == 0]   # Subtract 1 from all fish   fish_counts$n[1:(nrow(fish_counts) - 1)] <- fish_counts$n[2:nrow(fish_counts)]   # Reset zeroes to six   age_6 <- which(fish_counts$age == 6)   fish_counts$n[age_6] <- fish_counts$n[age_6] + n_zeroes   # Add eights for each zero   fish_counts$n[which(fish_counts$age == 8)] <- n_zeroes }  # How many lanternfish would there be after 256 days? sum(fish_counts$n) |>   format(scientific = FALSE) ## [1] \"1749945484935\""},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-6","dir":"Articles","previous_headings":"Day 7: The Treachery of Whales","what":"Part 1","title":"AoC 2021 (R)","text":"0.301 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day7.txt\") |>   scan(what = \"character\", sep = \",\") |>   as.numeric()  # Initialise objects xlim <- max(dat) results <- data.frame(x = 1:xlim, total_fuel_cost = NA)  # Determine the horizontal position that the crabs can align to using the least # fuel possible for (position in seq_len(xlim)) {   fuel_cost <- 0   for (crab in dat) {     fuel_cost <- fuel_cost + abs(crab - position)   }   results$total_fuel_cost[i] <- sum(fuel_cost) }  lowest <- which.min(results$total_fuel_cost) results$x[lowest] ## [1] 256 # How much fuel must they spend to align to that position? results$total_fuel_cost[lowest] ## [1] 1464430"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-6","dir":"Articles","previous_headings":"Day 7: The Treachery of Whales","what":"Part 2","title":"AoC 2021 (R)","text":"1.199 sec.","code":"# Initialise objects results <- data.frame(x = 1:xlim, total_fuel_cost = NA)  # Determine the horizontal position that the crabs can align to using the least # fuel possible for (position in seq_len(xlim)) {   fuel_cost <- 0   for (crab in dat) {     distance <- abs(crab - position)     fuel_cost <- fuel_cost + sum(0:distance)   }   results$total_fuel_cost[position] <- sum(fuel_cost) }  lowest <- which.min(results$total_fuel_cost) results$x[lowest] ## [1] 489 # How much fuel must they spend to align to that position? results$total_fuel_cost[lowest] ## [1] 101268110"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-7","dir":"Articles","previous_headings":"Day 8: Seven Segment Search","what":"Part 1","title":"AoC 2021 (R)","text":"0.024 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day8.txt\") |>   scan(what = \"character\", sep = \"\\n\")  # Tidy up data results <- c() for (i in seq_along(dat)) {   tmp <- strsplit(dat[i], \"\\\\| \")[[1]][2]   digits <- strsplit(tmp, \" \")[[1]]   results[i] <- sum(nchar(digits) %in% c(2, 4, 3, 7)) }  # How many times do digits 1, 4, 7, or 8 (length 2, 4, 3, and 7) appear? sum(results) ## [1] 321"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-7","dir":"Articles","previous_headings":"Day 8: Seven Segment Search","what":"Part 2","title":"AoC 2021 (R)","text":"0.251 sec.","code":"# Define functions --------------------------------------------------------  find_digit <- function(string_vector, num_characters) {   #' Find string in `string_vector` of length `num_characters`    string_vector[which(nchar(string_vector) == num_characters)] }  deconstruct <- function(string) {   #' Split string into vector of letters    strsplit(string, \"\")[[1]] }  contains_subset <- function(unknown_vector, known_string, contains = TRUE) {   #' contains_subset   #'   #' Find (1) which string in `unknown_vector` contains all segments   #' (characters) in `known_string` or (2) which string is the only one that   #' doesn't   #' @param unknown_vector an unknown vector   #' @param known_string a known string   #' @param contains (optional) default is `TRUE`    results <- c()   for (i in seq_along(unknown_vector)) {     known_segments <- deconstruct(known_string)     unknown_segments <- deconstruct(unknown_vector[i])     if (contains) {       results[i] <- all(known_segments %in% unknown_segments)     } else {       results[i] <- !all(known_segments %in% unknown_segments)     }   }   unknown_vector[which(results)] }  subset_of <- function(unknown_vector, known_string) {   #' Find the string in `unknown_vector` whose segments (characters) are a   #' subset of `known_string`    results <- c()   for (i in seq_along(unknown_vector)) {     known_segments <- deconstruct(known_string)     unknown_segments <- deconstruct(unknown_vector[i])     results[i] <- all(unknown_segments %in% known_segments)   }   unknown_vector[which(results)] }  decode <- function(unknown_vector, dictionary) {   #' Decode each string (digit) in `unknown_vector`    code <- c()   for (i in seq_along(unknown_vector)) {     # Check against each dictionary entry     entry <- c()     for (j in seq_len(nrow(dictionary))) {       length_match <- nchar(dictionary$segments[j]) == nchar(unknown_vector[i])       characters_match <- all(deconstruct(dictionary$segments[j]) %in%                                 deconstruct(unknown_vector[i]))       entry[j] <- length_match && characters_match     }     code[i] <- dictionary$number[which(entry)]   }   as.numeric(paste(code, collapse = \"\")) }  # Run simulation ----------------------------------------------------------  # Determine all of the wire/segment connections results <- c() for (i in seq_along(dat)) {   segments <- strsplit(dat[i], \" \\\\|\")[[1]][1]   segments <- strsplit(segments, \" \")[[1]]    # Known   one <- find_digit(segments, 2)   four <- find_digit(segments, 4)   seven <- find_digit(segments, 3)   eight <- find_digit(segments, 7)    # Remaining segments   remaining <- segments[-which(nchar(segments) %in% c(2, 4, 3, 7))]   # six, nine, zero (6)   length_six <- remaining[which(nchar(remaining) == 6)]   six <- contains_subset(length_six, one, FALSE)   nine <- contains_subset(length_six, four, TRUE)   zero <- length_six[!(length_six %in% c(six, nine))]   # two, three, five (5)   length_five <- remaining[which(nchar(remaining) == 5)]   five <- subset_of(length_five, six)   length_five <- length_five[!length_five %in% five]   three <- subset_of(length_five, nine)   two <- length_five[!length_five %in% three]    # Initialise dictionary   dict <- data.frame(number = 0:9,                      segments = c(zero, one, two, three, four,                                   five, six, seven, eight, nine))    # Decode the four-digit output values   digits <- strsplit(dat[i], \"\\\\| \")[[1]][2]   digits <- strsplit(digits, \" \")[[1]]   results[i] <- decode(digits, dict) }  # What do you get if you add up all of the output values? sum(results) ## [1] 1028926"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-8","dir":"Articles","previous_headings":"Day 9: Smoke Basin","what":"Part 1","title":"AoC 2021 (R)","text":"0.787 sec.","code":"# Read in data ------------------------------------------------------------  dat <- here(\"inst\", \"2021\", \"day9.txt\") |>   readLines() |>   strsplit(\"\") |>   do.call(what = \"rbind\") |>   apply(1, as.numeric)  # Define functions --------------------------------------------------------  compare_heights <- function(dat, row, column) {   #' Find `height` of adjacent points and if it's lower than all   #' `adjacent_points`, return risk level    height <- dat[row, column]   # Extract adjacent heights   adjacent_points <- c()   if (i != 1)     adjacent_points <- c(adjacent_points, dat[row - 1, column]) # above   if (j != ncol(dat))     adjacent_points <- c(adjacent_points, dat[row, column + 1]) # right   if (i != nrow(dat))     adjacent_points <- c(adjacent_points, dat[row + 1, column]) # below   if (j != 1)     adjacent_points <- c(adjacent_points, dat[row, column - 1]) # left   # Compare height to adjacent heights   if (all(height < adjacent_points))     return(data.frame(x = row, y = column, risk = height + 1)) }  # Run simulation ----------------------------------------------------------  # Find all of the low points on the heightmap and calculate risk level lowest_points <- data.frame(x = numeric(), y = numeric(), risk = numeric()) for (i in seq_len(nrow(dat))) {   for (j in seq_len(ncol(dat))) {     lowest_point <- compare_heights(dat, i, j)     lowest_points <- rbind.data.frame(lowest_points, lowest_point)   } }  # What is the sum of the risk levels of all low points on your heightmap? sum(lowest_points$risk) ## [1] 603"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-8","dir":"Articles","previous_headings":"Day 9: Smoke Basin","what":"Part 2","title":"AoC 2021 (R)","text":"66.071 sec.","code":"# Define functions --------------------------------------------------------  check_height <- function(dat, row, column) {   #' Check height is less than 9    if (dat[row, column] < 9)     return(data.frame(row = row, column = column, height = dat[row, column])) }  check_adjacent <- function(dat, row, column) {   #' Return neighbouring points that have a height less than 9    # Find height of adjacent points   adjacent_points <- data.frame(row = numeric(), column = numeric(),                                 height = numeric())    if (row != 1)            # Above     adjacent_points <- rbind(adjacent_points, check_height(dat, row - 1, column))   if (column != ncol(dat)) # Right     adjacent_points <- rbind(adjacent_points, check_height(dat, row, column + 1))   if (row != nrow(dat))    # Below     adjacent_points <- rbind(adjacent_points, check_height(dat, row + 1, column))   if (column != 1)         # Left     adjacent_points <- rbind(adjacent_points, check_height(dat, row, column - 1))    # Return neibouring points that should be checked   adjacent_points |>     dplyr::filter(height != 9) }  survey <- function(dat, row, column) {   #' For a particular `lowest_point`, survey the basin and return it's size    # Height of lowest point being surveyed   height <- dat[row, column]   # Initialise basin dataframe   basin <- data.frame(row = row, column = column, risk = height + 1)   # Find adjacent points with depth less than 9   neighbours <- check_adjacent(dat, row, column)   # Add them to the basin   tmp <- neighbours |>     dplyr::mutate(risk = height + 1) |>     dplyr::select(-height)   basin <- rbind(basin, tmp)    # Check neighbouring points   continue <- nrow(neighbours) > 0   while(continue) {     more_neighbours <- check_adjacent(dat,                                       neighbours$row[1],                                       neighbours$column[1])     # Remove this point from `neighbours`     neighbours <- neighbours[-1, ]     # Remove new neighbours that are already in the basin     more_neighbours <- setdiff(dplyr::select(more_neighbours, -height),                                dplyr::select(basin, -risk)) |>       dplyr::left_join(more_neighbours, by = c(\"row\", \"column\"))      # If any new neighbours are remaining     if (nrow(more_neighbours) > 0) {       # Add them to the basin       tmp <- more_neighbours |>         dplyr::mutate(risk = height + 1) |>         dplyr::select(-height)       basin <- rbind(basin, tmp)       # And add them to `neighbours` (for checking)       neighbours <- rbind(neighbours, more_neighbours)     }      continue <- nrow(neighbours) > 0   }   # Return size of basin   nrow(basin) }  # Run simulation ----------------------------------------------------------  # Find all of the low points on the heightmap and calculate basin size results <- c() for (i in seq_len(nrow(lowest_points))) {   # cat(\"\\r\", i, \"/\", nrow(lowest_points))   size <- survey(dat, lowest_points$x[i], lowest_points$y[i])   results <- c(results, size) }  # Multiply together the sizes of the three largest basins prod(tail(sort(results), 3)) ## [1] 786780"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-9","dir":"Articles","previous_headings":"Day 10: Syntax Scoring","what":"Part 1","title":"AoC 2021 (R)","text":"0.077 sec.","code":"# Read in data ------------------------------------------------------------  dat <- here(\"inst\", \"2021\", \"day10.txt\") |>   readLines()  corrupted_score <- function(character) {   score_table <- data.frame(char = c(\")\", \"]\", \"}\", \">\"),                             val = c(3, 57, 1197, 25137))   score_table$val[which(score_table$char == character)] }  # Run simulation ----------------------------------------------------------  total <- 0 remove_lines <- c()  for (i in seq_along(dat)){   expecting <- c()   points <- NA   check_this <- strsplit(dat[i], \"\")[[1]]    for (j in seq_along(check_this)) {     if (check_this[j] == \"(\"){       expecting <- c(expecting, \")\")      } else if (check_this[j] == \"[\") {       expecting <- c(expecting, \"]\")      } else if (check_this[j] == \"{\") {       expecting <- c(expecting, \"}\")      } else if (check_this[j] == \"<\") {       expecting <- c(expecting, \">\")      } else {       # If `check_this` matches the last expected value, remove it       if (check_this[j] == tail(expecting, 1)) {         expecting <- expecting[-length(expecting)]        } else if (is.na(points)) {         # Otherwise add the score to `total`         points <- corrupted_score(check_this[j])         total <- total + points         remove_lines <- c(remove_lines, i)         break       }     }   } }  # Find the first illegal character in each corrupted line of the navigation # subsystem. What is the total syntax error score for those errors? total ## [1] 296535"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-9","dir":"Articles","previous_headings":"Day 10: Syntax Scoring","what":"Part 2","title":"AoC 2021 (R)","text":"0.176 sec.","code":"# Remove corrupted lines incomplete_lines <- dat[-remove_lines]  incomplete_score <- function(character) {   score_table <- data.frame(char = c(\")\", \"]\", \"}\", \">\"),                             val = c(1, 2, 3, 4))   score_table$val[which(score_table$char == character)] }  results <- c() for (i in seq_along(incomplete_lines)){   expecting <- c()   check_this <- strsplit(incomplete_lines[i], \"\")[[1]]   points <- 0    for (j in seq_along(check_this)) {     if (check_this[j] == \"(\"){       expecting <- c(expecting, \")\")      } else if (check_this[j] == \"[\") {       expecting <- c(expecting, \"]\")      } else if (check_this[j] == \"{\") {       expecting <- c(expecting, \"}\")      } else if (check_this[j] == \"<\") {       expecting <- c(expecting, \">\")     } else {       # If `check_this` matches the last expected value, remove it       if (check_this[j] == tail(expecting, 1)) {         expecting <- expecting[-length(expecting)]       }     }   }   expecting <- rev(expecting)    # Calculate score   for (k in seq_along(expecting)) {     points <- (points * 5) + incomplete_score(expecting[k])   }   results <- c(results, points)  }  # Find the completion string for each incomplete line, score the completion # strings, and sort the scores. What is the middle score? index <- ceiling(length(results) / 2) value <- sort(results)[index] format(value, scientific = FALSE) ## [1] \"4245130838\""},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-10","dir":"Articles","previous_headings":"Day 11: Dumbo Octopus","what":"Part 1","title":"AoC 2021 (R)","text":"8.643 sec.","code":"# Read in data ------------------------------------------------------------  dat <- here(\"inst\", \"2021\", \"day11.txt\") |>   scan(what = \"character\") |>   strsplit(\"\") |>   do.call(what = rbind) |>   apply(1, as.numeric)  # Define functions --------------------------------------------------------  find_neighbours <- function(x, y, flashing_now, flashed_previously, octopus) {   # Index neighbours   tmp <- rbind(data.frame(row = x - 1, col = (y - 1):(y + 1)), # above                data.frame(row = x, col = c(y - 1, y + 1)),     # sides                data.frame(row = x + 1, col = (y - 1):(y + 1))) # below   # Remove invalid coordinates   xlim <- ncol(octopus) + 1   ylim <- nrow(octopus) + 1   tmp <- dplyr::filter(tmp, row != 0, col != 0, row != xlim, col != ylim)   # Add to `neighbours`, remove duplicates, and remove those that are flashing   # now or have flashed previously   tmp |>     unique() |>     dplyr::anti_join(data.frame(flashing_now), by = c(\"row\", \"col\")) |>     dplyr::anti_join(data.frame(flashed_previously), by = c(\"row\", \"col\")) |>     as.matrix() }  timestep <- function(octopus) {   # Increases the energy level of each octopus by 1   octopus <- octopus + 1   done <- matrix(nrow = 0, ncol = 2)    # Any octopus with an energy level greater than 9 flashes and has its energy   # level reset to 0, the energy level of all adjacent octopuses (including   # octopuses that are diagonally adjacent) increases by 1. If this causes an   # octopus to have an energy level greater than 9, it also flashes   while (any(octopus > 9)) {     # Check if energy level is greater than 9     flash <- which(octopus > 9, arr.ind = T)     # Flash     done <- rbind(done, flash)     # Reset energy     octopus[flash] <- 0      # For each flashing octopus     for (j in seq_len(nrow(flash))) {       x <- unname(flash[j, \"row\"])       y <- unname(flash[j, \"col\"])       # Find adjacent octopi       neighbours <- find_neighbours(x, y, flash, done, octopus)       # Increase energy level by 1       octopus[neighbours] <- octopus[neighbours] + 1     }   }   # Latest flashes   list(octopus = octopus, latest_flashes = nrow(done)) }  # Run simulation ----------------------------------------------------------  octopus <- dat count <- 0  # Given the starting energy levels of the dumbo octopuses in your cavern, # simulate 100 steps. for (i in 1:100) {   # cat(\"\\r\", i, \"of 100\")   data <- timestep(octopus)   octopus <- data$octopus   count <- count + data$latest_flashes }  # How many total flashes are there after 100 steps? count ## [1] 1743"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-10","dir":"Articles","previous_headings":"Day 11: Dumbo Octopus","what":"Part 2","title":"AoC 2021 (R)","text":"28.901 sec.","code":"octopus <- dat count <- 1  # What is the first step during which all octopuses flash? while (sum(octopus) != 0) {   # cat(\"\\r\", count)   data <- timestep(octopus)   octopus <- data$octopus   count <- count + 1 }  count ## [1] 365"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-11","dir":"Articles","previous_headings":"Day 12: Passage Pathing","what":"Part 1","title":"AoC 2021 (R)","text":"12.439 sec.","code":"# Read in data dat <- here(\"inst\", \"2021\", \"day12.txt\") |>   read.table(sep = \"-\")  # Tidy up data dat <- rbind(dat, rename(dat, V1 = V2, V2 = V1)) |>   dplyr::rename(from = V1,                 to = V2) |>   dplyr::filter(from != \"end\",                 to != \"start\")  # Initialise routes completed_routes <- list() unfinished_routes <- filter(dat, from == \"start\") unfinished_routes <- lapply(seq_len(nrow(unfinished_routes)),                             function(x) unname(unlist(unfinished_routes[x,])))  # Plot routes through cave system while (length(unfinished_routes) > 0) {   this_route <- unfinished_routes[[1]]   this_cave <- tail(this_route, 1)    # Record next step(s) of the route   next_steps <- dplyr::filter(dat, from == this_cave, to != \"start\")$to    # If the exit has been found, move the route to `completed_routes`   if (\"end\" %in% next_steps) {     completed_routes <- c(completed_routes, list(c(this_route, \"end\")))     next_steps <- setdiff(next_steps, \"end\")   }    # If the cave is small and has already been visited, ignore it   small <- next_steps[vapply(next_steps, function(x)     grepl(\"^[[:lower:]]+$\", x), logical(1))]   big <- setdiff(next_steps, small)   next_steps <- c(setdiff(small, this_route), big)    # Record next step(s) of the route   add_these <- lapply(next_steps, function(x) c(this_route, x))    # Record steps and tidy up   unfinished_routes <- c(unfinished_routes, add_these)   unfinished_routes <- unfinished_routes[-1] }  # How many paths through this cave system are there that visit small caves at # most once? length(completed_routes) ## [1] 3887"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-11","dir":"Articles","previous_headings":"Day 12: Passage Pathing","what":"Part 2","title":"AoC 2021 (R)","text":"use different method Part 2, since takes long calculate number routes. 18.14 sec.","code":"# Initialise routes unfinished <- dplyr::filter(dat, from == \"start\") complete <- data.frame()  last_step <- \"to\"  # Plot routes through cave system while (nrow(unfinished) != 0) {   # Record next step(s) of the route   unfinished <- dplyr::left_join(unfinished, dat,                                  by = setNames(\"from\", last_step))    # Extract column name of the last step   last_step <- tail(names(unfinished), 1)    # For each unfinished route, count the number of small caves that were   # visited more than once   test <- apply(unfinished, 1, function(x) {     duplicates <- x[duplicated(unlist(x))]     islower <- grepl(\"^[[:lower:]]+$\", duplicates)     sum(islower)})   # Remove routes where more than one small cave was visited more than once   index <- which(test > 1)   if (length(index) > 0)     unfinished <- unfinished[-index, ]    # Add completed routes to `complete`   complete <- dplyr::bind_rows(complete,                                dplyr::filter(unfinished,                                              get(last_step) == \"end\"))    # Remove completed routes from `unfinished`   unfinished <- dplyr::filter(unfinished, get(last_step) != \"end\") }  # If we visit a single small cave twice, how many paths through this cave # system are there? nrow(complete) ## [1] 104834"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-12","dir":"Articles","previous_headings":"Day 13: Transparent Origami","what":"Part 1","title":"AoC 2021 (R)","text":"0.09 sec.","code":"# Read in data ------------------------------------------------------------  dat <- here(\"inst\", \"2021\", \"day13.txt\") |>   read.table(sep = \"-\")  # Tidy up data dots <- dat |>   dplyr::filter(!grepl(\"^fold\", V1)) |>   tidyr::separate(V1, c(\"y\", \"x\"), convert = TRUE) |>   dplyr::mutate(x = x + 1,                 y = y + 1) |>   dplyr::select(x, y)  xlim <- max(dots$x) ylim <- max(dots$y)  instructions <- dplyr::filter(dat, grepl(\"^fold\", V1)) |>   dplyr::mutate(V1 = gsub(\"^.*([a-z]=[0-9]*)$\", \"\\\\1\", V1)) |>   tidyr::separate(V1, c(\"axis\", \"value\")) |>   dplyr::mutate(value = as.numeric(value) + 1)  # Generate grid of dots paper <- matrix(FALSE, nrow = xlim, ncol = ylim) for (i in seq_len(nrow(dots))) paper[dots$x[i], dots$y[i]] <- TRUE  # Define functions --------------------------------------------------------  fold_left <- function(grid, value) {   #' Make a vertical fold    left <- grid[, 1:(value - 1)]   right <- grid[, (value + 1):ncol(grid)]   pad <- matrix(0, nrow = nrow(grid), ncol = abs(ncol(left) - ncol(right)))   if (ncol(right) < ncol(left)) {     right <- cbind(right, pad)   } else if (ncol(right) > ncol(left)) {     left <- cbind(pad, left)   }   left | right[, ncol(right):1] }  # Run simulation ----------------------------------------------------------  # Make first fold results <- fold_left(paper, instructions[1,]$value)  # How many dots are visible after completing just the first fold instruction on # your transparent paper? sum(results > 0) ## [1] 847"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-12","dir":"Articles","previous_headings":"Day 13: Transparent Origami","what":"Part 2","title":"AoC 2021 (R)","text":"0.249 sec.","code":"# Define functions --------------------------------------------------------  fold_up <- function(grid, value) {   #' Make a horizontal fold    upper <- grid[1:(value - 1), ]   lower <- grid[(value + 1):nrow(grid), ]   pad <- matrix(FALSE, nrow = abs(nrow(upper) - nrow(lower)), ncol = ncol(upper))   if (nrow(upper) < nrow(lower)) {     upper <- rbind(pad, upper)   } else if (nrow(upper) > nrow(lower)) {     lower <- rbind(lower, pad)   }   upper | lower[nrow(lower):1, ] }  # Run simulation ----------------------------------------------------------  fold_this <- paper  # Finish folding the transparent paper according to the instructions. The # manual says the code is always eight capital letters. for (i in seq_len(nrow(instructions))) {   if (instructions$axis[i] == \"x\") {     fold_this <- fold_left(fold_this, instructions$value[i])    } else if(instructions$axis[i] == \"y\") {     fold_this <- fold_up(fold_this, instructions$value[i])   } }  # What code do you use to activate the infrared thermal imaging camera system? coords <- which(fold_this, arr.ind = TRUE) |>   as.data.frame() |>   dplyr::mutate(value = 1,                 row = max(row) - row)  ggplot2::ggplot(coords, ggplot2::aes(x = col, y = row, fill = value)) +   ggplot2::geom_tile(fill = \"goldenrod2\") +   ggplot2::coord_fixed() +   ggplot2::theme_void() +   ggplot2::theme(legend.position = \"none\")"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-13","dir":"Articles","previous_headings":"Day 14: Extended Polymerization","what":"Part 1","title":"AoC 2021 (R)","text":"0.081 sec.","code":"# Read in data ------------------------------------------------------------  # Read in polymer template path <- here(\"inst\", \"2021\", \"day14-test.txt\") template <- path |>   scan(what = \"character\", n = 1)  # Read in pair insertion rules rules <- path |>   scan(what = \"character\", sep = \"\\n\", skip = 2) |>   data.frame() |>   setNames(\"x\") |>   tidyr::separate(x, c(\"pair\", \"insert\"), \" -> \")  # Run simulation ----------------------------------------------------------  current_string <- strsplit(template, \"\")[[1]]  # Apply 10 steps of pair insertion to the polymer template and find the most # and least common elements in the result for (i in seq_len(10)) {   next_string <- \"\"   # cat(\"\\r\", i)   for (j in seq_len(length(current_string) - 1)) {     index <- which(rules$pair == paste(current_string[j:(j + 1)],                                        collapse = \"\"))     if (length(index) != 0) {       next_string <- paste0(next_string, current_string[j], rules$insert[index])     } else {       next_string <- paste0(next_string, current_string[j])     }   }   next_string <- paste0(next_string, tail(current_string, 1))   current_string <- strsplit(next_string, \"\")[[1]] }  # What do you get if you take the quantity of the most common element and # subtract the quantity of the least common element? freq <- table(current_string) max(freq) - min(freq) ## [1] 1588"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"alternative-solution","dir":"Articles","previous_headings":"Day 14: Extended Polymerization > Part 1","what":"Alternative solution","title":"AoC 2021 (R)","text":"0.159 sec. Part 1 slow use method part 2.","code":"current_string <- strsplit(template, \"\")[[1]]  for (i in 1:10) {   # cat(\"\\r\", i)   pairs <- vapply(seq_len(length(current_string) - 1), function(x)     paste(current_string[x:(x + 1)], collapse = \"\"), character(1)) |>     data.frame() |>     setNames(\"pair\")    next_string <- dplyr::left_join(pairs, rules,                                   by = \"pair\") |>     tidyr::separate(pair, c(\"first\", \"last\"), \"(?<=[A-Z])\") |>     tidyr::unite(string, c(first, insert), sep = \"\", na.rm = TRUE) |>     dplyr::select(string) |>     unlist() |>     paste(collapse = \"\") |>     paste0(tail(current_string, 1, collapse = \"\"))    current_string <- strsplit(next_string, \"\")[[1]] }  freq <- table(current_string) max(freq) - min(freq) ## [1] 1588"},{"path":[]},{"path":[]},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-14","dir":"Articles","previous_headings":"Day 17: Trick Shot","what":"Part 1","title":"AoC 2021 (R)","text":"20.981 sec.","code":"# Read in data ------------------------------------------------------------ dat <- here(\"inst\", \"2021\", \"day17.txt\") |>   readLines()  # Extract target coordinates xrange <- gsub(\"^.*x=(.*)\\\\.\\\\.(.*),.*$\", \"\\\\1 \\\\2\", dat) |>   strsplit(\" \") |>   unlist() |>   as.numeric() yrange <- gsub(\"^.*y=(.*)\\\\.\\\\.(.*)$\", \"\\\\1 \\\\2\", dat) |>   strsplit(\" \") |>   unlist() |>   as.numeric()  # Define functions --------------------------------------------------------  # Move one step move <- function(status) {   #' Move one step   #'   #' @param status last step    x <- status$x + status$vx   y <- status$y + status$vy    vx <- status$vx   vy <- status$vy   vx <- dplyr::if_else(vx > 0, vx - 1,                        dplyr::if_else(vx < 0, vx + 1, vx))   vy <- vy - 1    data.frame(x = x, y = y, vx = vx, vy = vy) }  launch <- function(df, trial, xrange, yrange) {   #' Launch probe until target is hit or overshot    continue <- TRUE   step <- 1   while (continue) {     update <- move(tail(df, 1))     df <- rbind(df, mutate(trial = trial, step = step, update))     foundtarget <- dplyr::if_else(       update$x >= xrange[1] & update$x <= xrange[2] &         update$y >= yrange[1] & update$y <= yrange[2],       TRUE, FALSE)     overshot <- dplyr::if_else(update$x > xrange[2] | update$y < yrange[2],                                TRUE, FALSE)     continue <- dplyr::if_else(foundtarget | overshot, FALSE, TRUE)     step <- step + 1   }   mutate(df, hit = foundtarget) }  # Run simulation ----------------------------------------------------------  start <- c(0, 0) velocity <- c(0, 1) n <- 1  results <- data.frame()  for (i in 1:120) {   trial <- data.frame(trial = n,                       step = 0,                       x = start[1],                       y = start[2],                       vx = velocity[1],                       vy = velocity[2])    results <- rbind(results, launch(trial, n, xrange, yrange))    n <- n + 1    if (tail(results, 1)$x < xrange[1]) {     velocity[1] <- velocity[1] + 1   } else if (tail(results, 1)$x > xrange[2]) {     velocity[1] <- velocity[1] - 1   } else {     velocity[2] <- velocity[2] + 1   } }  # Find the initial velocity that causes the probe to reach the highest y # position and still eventually be within the target area after any step this_trial <- results |>   dplyr::filter(hit == T) |>   dplyr::filter(y == max(y)) |>   dplyr::pull(trial) |>   unique()  # Initial y velocity results |>   dplyr::filter(trial == this_trial,                 step == 0) |>   dplyr::pull(vy) ## [1] 79 # What is the highest y position it reaches on this trajectory? results |>   dplyr::filter(trial == this_trial) |>   dplyr::filter(y == max(y)) |>   dplyr::pull(y) |>   unique() ## [1] 3160"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-13","dir":"Articles","previous_headings":"Day 17: Trick Shot","what":"Part 2","title":"AoC 2021 (R)","text":"31.834 sec.","code":"# Read in data ------------------------------------------------------------ dat <- here(\"inst\", \"2021\", \"day17.txt\") |>   readLines()  # Extract target coordinates xrange <- gsub(\"^.*x=(.*)\\\\.\\\\.(.*),.*$\", \"\\\\1 \\\\2\", dat) |>   strsplit(\" \") |> unlist() |> as.numeric() yrange <- gsub(\"^.*y=(.*)\\\\.\\\\.(.*)$\", \"\\\\1 \\\\2\", dat) |>   strsplit(\" \") |> unlist() |> as.numeric()  # Define functions --------------------------------------------------------  possible_x <- function(range, min_v, max_v) {   #' Test which velocities might hit the target   #'   #' @param range range of target   #' @param min_v minimum velocity to try   #' @param max_v maximum velocity to try    output <- c()   for (v in min_v:max_v) {     # Calculate position of points     points <- cumsum(seq(v, 1, -1))      # Check if any points hit the target zone     if (any(between(points, min(range), max(range))))       output <- c(output, v)   }   output }  possible_y <- function(range, min_v, max_v) {   #' Test which velocities might hit the target   #'   #' @param range of target   #' @param min_v minimum velocity to try   #' @param max_v maximum velocity to try    output <- c()   for (v in min_v:max_v) {     z <- max(abs(range))      # Calculate position of points below the x axis     if (v > 0) {       points <- -cumsum((v + 1):(v * z))     } else if (v < 0) {       points <- cumsum(seq(v, (v * z), -1))     } else {       points <- 0       subtract <- 1       while (min(points) > range[1]) {         points <- c(points, (tail(points, 1) - subtract))         subtract <- subtract + 1       }     }      # Check if any points hit the target zone     if (any(between(points, min(range), max(range))))       output <- c(output, v)   }   output }  # Initialise variables ----------------------------------------------------  # Minimum x_velocity (when x_velocity = i, distance in x axis = cumsum(1:i)) xv_min <- optimize(function(x) abs(max(cumsum(1:x)) - xrange[1]), 1:10) |>   purrr::pluck(\"minimum\") |> round()  # Which velocities might hit the target? poss_xv <- possible_x(range = xrange,                       min_v = xv_min,                       max_v = 500)  poss_yv <- possible_y(range = yrange,                       min_v = -2500,                       max_v = 500)  velocities <- expand.grid(poss_xv, poss_yv) |>   dplyr::rename(xv = Var1, yv = Var2)  start <- c(0, 0)  # Check all combinations --------------------------------------------------  results <- lapply(seq_len(nrow(velocities)), function(i) {   # Extract velocities   xv <- velocities$xv[i]   yv <- velocities$yv[i]    # Calculate trajectory   z <- max(abs(yrange))    if (yv > 0) {     y <- c(0, cumsum(seq(yv, 1, -1)))     y <- c(y, rev(y), -cumsum((yv + 1):(yv * z)))   } else if (yv < 0) {     y <- c(0, cumsum(yv:(yv * z)))   } else {     y <- c(0, 0)     subtract <- 1     while (min(y) > yrange[1]) {       y <- c(y, (tail(y, 1) - subtract))       subtract <- subtract + 1     }   }    x <- c(0, cumsum(seq(xv, 1, -1)))    if (length(x) > length(y)) {     y <- c(y, rep(tail(y, 1), length(x) - length(y)))   } else {     x <- c(x, rep(tail(x, 1), length(y) - length(x)))   }    # Paste coordinates together   trajectory <- cbind.data.frame(x = x, y = y)    # Check whether points have hit the target   hit <- trajectory |>     dplyr::filter(between(x, xrange[1], xrange[2]),                   between(y, yrange[1], yrange[2]))    if (nrow(hit) != 0) {     out <- data.frame(xv = xv,                       yv = yv,                       y_max = max(trajectory$y))   } else {     out <- NULL   }   out }) |>   do.call(what = rbind)  # Find the initial velocity that causes the probe to reach the highest y # position and still eventually be within the target area after any step results |>   dplyr::filter(y_max == max(y_max)) ##   xv yv y_max ## 1 24 79  3160 # What is the highest y position it reaches on this trajectory? results |>   dplyr::filter(y_max == max(y_max)) |>   dplyr::pull(y_max) |>   unique() ## [1] 3160 # How many distinct initial velocity values cause the probe to be within the # target area after any step? results |>   dplyr::select(xv, yv) |>   unique() |>   nrow() ## [1] 1928"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-15","dir":"Articles","previous_headings":"Day 18: Snailfish","what":"Part 1","title":"AoC 2021 (R)","text":"5.465 sec.","code":"# Read in data ------------------------------------------------------------  dat <- here(\"inst\", \"2021\", \"day18.txt\") |>   readLines()  # Define functions --------------------------------------------------------  explode <- function(dat) {   #' Function to check for and carry out explosion    count <- 0   i <- 1   left <- NA   right <- NA    # Check for explosion   while(i != length(dat)) {     if (dat[i] == \"[\") {       count <- count + 1      } else if (grepl(\"[0-9]\", dat[i])) {        if (dat[i + 1] == \",\" & grepl(\"[0-9]\", dat[i + 2]) & count > 4) {         right <- head(grep(\"[0-9]\", dat[(i + 3):length(dat)]), 1) + i + 2         if (length(right) == 0) right <- NA         left <- tail(grep(\"[0-9]\", dat[1:(i - 1)]), 1)         if (length(left) == 0) left <- NA         break       }      } else if (dat[i] == \"]\") {       count <- count - 1     }     i <- i + 1   }    # Explode   if (is.na(left) & is.na(right)) {     return(NA)    } else if (is.na(left)) {     tmp <- dat     tmp[right] <- as.numeric(dat[right]) + as.numeric(dat[i + 2])     tmp <- tmp[-c(i:(i + 3))]     tmp[i - 1] <- 0     return(tmp)    } else if (is.na(right)) {     tmp <- dat[-c(i:(i + 3))]     tmp[i - 3] <- as.numeric(dat[left]) + as.numeric(dat[i])     tmp[i - 1] <- 0     return(tmp)    } else {     tmp <- dat     tmp[left] <- as.numeric(dat[left]) + as.numeric(dat[i])     tmp[right] <- as.numeric(dat[right]) + as.numeric(dat[i + 2])     tmp <- tmp[-c(i:(i + 3))]     tmp[i - 1] <- 0     return(tmp)   } }  split <- function(dat) {   #' Function to check for and carry out split    # Check for split   index <- NA   for (i in seq_along(dat)) {     if (grepl(\"[0-9]\", dat[i]) && as.numeric(dat[i]) >= 10) {       index <- i       break     }   }    # Split   if (is.na(index)) {     return(NA)    } else {     left <- dat[1:(index - 1)]     right <- dat[(index + 1):length(dat)]     tmp <- as.numeric(dat[index])     tmp <- c(\"[\", floor(tmp / 2), \",\", ceiling(tmp / 2), \"]\")     return(c(left, tmp, right))   } }  reduce_snailfish <- function(dat) {   #' Function to reduce a snailfish number    try_this <- dat   continue <- TRUE   it_split <- FALSE    while (continue) {     result <- explode(try_this)     it_exploded <- !all(is.na(result))      if (it_exploded) {       try_this <- result       it_split <- FALSE     } else {       result <- split(try_this)       it_split <- !all(is.na(result))        if (!it_exploded & !it_split) {         return(try_this)       } else {         try_this <- result       }     }   } }  add_snailfish <- function(first, second) {   #' Add snailfish numbers   #'   if (length(first) > 1)     first <- paste(first, collapse = \"\")    paste0(\"[\", first, \",\", second, \"]\") |>     strsplit(\"\") |>     unlist() |>     reduce_snailfish() }  check_magnitude <- function(answer) {   #' Function to check magnitude of answer    while(length(answer) != 1) {     count <- 1     depth <- 1     for (i in tail(seq_along(answer), -1)) {       if (answer[i] == \"[\") {         count <- count + 1        } else if (answer[i] == \"]\") {         count <- count - 1       }       depth[i] <- count     }      deepest <- which(depth == max(depth))      index <- R.utils::seqToIntervals(deepest) |>       data.frame() |>       dplyr::pull(from) |>       rev() + 1      for (j in index) {       first <- 3 * as.numeric(answer[j])       second <- 2 * as.numeric(answer[j + 2])        answer <- answer[-c(j:(j + 3))]       answer[j - 1] <- first + second     }   }    return(as.numeric(answer)) }  # Run simulation ----------------------------------------------------------  first <- dat[1] for (i in tail(seq_along(dat), -1)) {   result <- add_snailfish(first, dat[i])   first <- result }  # Add up all of the snailfish numbers from the homework assignment in the # order they appear. What is the magnitude of the final sum?  check_magnitude(result) ## [1] 4116"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-14","dir":"Articles","previous_headings":"Day 18: Snailfish","what":"Part 2","title":"AoC 2021 (R)","text":"106.822 sec.","code":"# What is the largest magnitude of any sum of two different snailfish numbers # from the homework assignment?  n <- length(dat) combinations <- expand.grid(1:n, 1:n) |>   dplyr::filter(Var1 != Var2) results <- c()  for (i in seq_len(nrow(combinations))) {   # cat(\"\\r\", i, \"of\", nrow(combinations))   first <- combinations$Var1[i]   second <- combinations$Var2[i]   results[i] <- add_snailfish(dat[first], dat[second]) |>     check_magnitude() }  max(results) ## [1] 4638"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-16","dir":"Articles","previous_headings":"Day 19: Beacon Scanner","what":"Part 1","title":"AoC 2021 (R)","text":"186.489 sec.","code":"# Read in data ------------------------------------------------------------ dat <- here(\"inst\", \"2021\", \"day19.txt\") |>   readLines() |>   data.frame() |>   setNames(\"data\")  start <- grep(\"scanner\", dat$data) end <- c(tail(start - 1, -1), nrow(dat))  scans <- lapply(seq_along(start), function(x) {   tmp <- dat[start[x]:end[x], ]   tmp <- tmp[-1]   index <- which(tmp == \"\")   if (length(index) != 0)     tmp <- tmp[-index]   out <- data.frame(data = tmp) |>     tidyr::separate(col = data, into = c(\"d1\", \"d2\", \"d3\"), sep = \",\") |>     dplyr::mutate_if(is.character, as.numeric) |>     as.matrix()   colnames(out) <- NULL   out })  # Define functions --------------------------------------------------------  spin <- function(x) {   #' Spin around an axis    vec <- if(is.vector(x)) x else tail(x, 1)   for (i in 1:3) {     vec <- c(vec[3], vec[2], -vec[1])     x <- rbind(x, vec)   }   unname(x) }  flip <- function(x) {   #' Turn upside down    vec <- if(is.vector(x)) x else tail(x, 1)   vec <- c(-vec[1], -vec[2], vec[3])   rbind(x, vec) |>     unname() }  reorient <- function(x) {   #' Take the next axis as up    vec <- if(is.vector(x)) x else tail(x, 1)   vec <- c(vec[3], vec[1], vec[2])   rbind(x, vec) |>     unname() }  spin_and_flip <- function(x) {   x |> spin() |> flip() |> spin() }  get_combinations <- function(x) {   x |> spin_and_flip() |>     reorient() |>     spin_and_flip() |>     reorient() |>     spin_and_flip() }  transform <- function(coordinate, transformation) {   index <- abs(transformation)   sign <- vapply(transformation, function(x) if (x > 0) 1 else -1, numeric(1))   reindex <- c(coordinate[index[1]], coordinate[index[2]], coordinate[index[3]])   reindex * sign }  transform_all <- function(scanner_output, transformation) {   lapply(seq_len(nrow(scanner_output)), function(x)     transform(scanner_output[x, ], transformation)) |>     do.call(what = rbind) }  # Assemble the full map of beacons ----------------------------------------  transformations <- get_combinations(1:3) scanners <- data.frame(scanner = 0, x = 0, y = 0, z = 0)  while(nrow(scanners) != length(scans)) {   results <- list()    # Compare each scanner output to that of scanner 0   for (i in tail(seq_along(scans), -1)) {      # cat(\"\\r\", i, \"of\", length(scans), \"-\",     #     length(scans) - nrow(scanners), \"left to find...\")      if ((i - 1) %in% scanners$scanner) next      scanner_zero <- scans[[1]]     scanner_i <- scans[[i]]      for (j in seq_len(nrow(transformations))) {       this_transformation <- transformations[j, ]        # Transform `scanner_i` by `this_transformation`       transformed_scanner <- transform_all(scanner_i, this_transformation)        # Try subtracting each beacon coordinate in `scanner_zero` from each       # beacon coordinate in `transformed_scanner` (transformation of       # `scanner_i`)       subtract <- lapply(seq_len(nrow(scanner_zero)), function(x)         apply(transformed_scanner, 1, function(y) y - scanner_zero[x, ]) |>           t()) |>         do.call(what = rbind.data.frame) |>         tidyr::unite(unscramble) |>         dplyr::group_by(unscramble) |>         dplyr::summarize(n = dplyr::n())        # If 12 or more matches are found, record the scanner position       if (max(subtract$n) >= 12) {         this_coordinate <- subtract |>           dplyr::filter(n == max(n)) |>           tidyr::separate(unscramble, c(\"x\", \"y\", \"z\"), sep = \"_\") |>           dplyr::select(-n) |>           data.frame() |>           dplyr::mutate_if(is.character, as.numeric)          colnames(this_coordinate) <- c(\"x\", \"y\", \"z\")          scanners <- rbind(scanners,                           cbind(scanner = i - 1, this_coordinate))         results[[i]] <- list(scanner1 = 0,                              scanner2 = i - 1,                              beacon = this_coordinate,                              transformation = this_transformation)         break       }     }   }    # Which beacons can see each other?   relatives <- lapply(seq_along(results), function(x)     if (is.null(results[[x]])) {       NA     } else {       data.frame(from = results[[x]]$scanner1,                  to = results[[x]]$scanner2)     }   ) |>     do.call(what = rbind)    # Append new beacon coordinates to scanner outputs   for (k in seq_len(nrow(relatives))) {     if (all(is.na(relatives[k,]))) next      tmp <- results[[k]]     from <- relatives$from[k] + 1     to <- relatives$to[k] + 1      # Transform `to` scanner coordinates relative to `from` scanner coordinates     transformed_to <- transform_all(scans[[to]], tmp$transformation) |>       apply(1, function(x) x - tmp$beacon) |>       do.call(what = rbind)     colnames(transformed_to) <- c(\"X1\", \"X2\", \"X3\")      # Add beacon coordinates to `from` scanner     scans[[from]] <- transformed_to |>       dplyr::anti_join(data.frame(scans[[from]]),                        by = c(\"X1\", \"X2\", \"X3\")) |>       as.matrix() |>       rbind(scans[[from]]) |>       unique()   } }  # How many beacons are there? scans[[1]] |>   unique() |>   nrow() ## [1] 330"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-15","dir":"Articles","previous_headings":"Day 19: Beacon Scanner","what":"Part 2","title":"AoC 2021 (R)","text":"2.004 sec.","code":"manhattan <- function(a, b) {   abs(a - b) |>     sum() }  index <- seq_len(nrow(scanners)) - 1 combinations <- t(combn(index, 2))  res <- lapply(seq_len(nrow(combinations)), function(x) {   first <- combinations[x, 1]   second <- combinations[x, 2]   a <- scanners |>     dplyr::filter(scanner == first) |>     dplyr::select(-scanner) |> unlist()   b <- scanners |>     dplyr::filter(scanner == second) |>     dplyr::select(-scanner) |> unlist()   manhattan(a, b) }) |> unlist()  # What is the largest Manhattan distance between any two scanners? max(res) ## [1] 9634"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-17","dir":"Articles","previous_headings":"Day 20: Trench Map","what":"Part 1","title":"AoC 2021 (R)","text":"9.614 sec.","code":"# Read in data ------------------------------------------------------------ path <- here(\"inst\", \"2021\", \"day20.txt\") algorithm <- path |>   readLines(n = 1) |>   strsplit(\"\") |>   unlist()  input <- path |>   scan(what = \"character\", skip = 2) |>   vapply(function(x) as.data.frame(strsplit(x, \"\")[[1]]),          data.frame(1)) |>   do.call(what = rbind) |>   unname()  # Define functions --------------------------------------------------------  pix2bin <- function(pixels) {   #' Convert matrix of input pixels into a decimal number    tmp <- pixels |>     t() |>     matrix(nrow = 1)   as.numeric(tmp == \"#\") |>     paste(collapse = \"\") |>     strtoi(base = 2) }  get_pixels <- function(input, coord) {   rows <- (coord[1] - 1):(coord[1] + 1)   cols <- (coord[2] - 1):(coord[2] + 1)   input[rows, cols] }  scan_input <- function(input, pad) {    with_buffer <- rbind(pad, pad, input, pad, pad)   with_buffer <- cbind(pad, pad, with_buffer, pad, pad) |> unname()    index <- 2:(ncol(with_buffer) - 1)   input_coords <- lapply(index, function(x) cbind(x = x, y = index)) |>     do.call(what = rbind.data.frame)    lapply(seq_len(nrow(input_coords)), function(x) {     index <- with_buffer |>       get_pixels(unlist(input_coords[x, ])) |>       pix2bin()     data.frame(index = index,                x = input_coords$x[x] - 1,                y = input_coords$y[x] - 1)   }) |>     do.call(what = rbind) }  output_pixel <- function(values, algorithm) {   values |>     dplyr::rowwise() |>     dplyr::mutate(pixel = dplyr::nth(algorithm, index + 1)) |>     dplyr::select(-index) |>     data.frame() }  generate_image <- function(values) {   matrix(values$pixel, ncol = max(values$y), nrow = max(values$x),          byrow = TRUE) }  viewer <- function(img) {   cat(\"\\n\")   for (i in seq_len(nrow(img))) {     cat(img[i, ], \"\\n\")   } }  enhance_image <- function(input, n, algorithm) {   img <- input   odd <- TRUE   first <- head(algorithm, 1)   second <- tail(algorithm, 1)    # When the first element of the algorithm doesn't match the last one, change   # the composition of the image border with each iteration   correction <- first != second    for (i in seq_len(n)) {     if (correction)       pad <- ifelse(odd, second, first)     img <- img |>       scan_input(pad) |>       output_pixel(algorithm) |>       generate_image()      odd <- !odd   }   img }  # Run simulation ----------------------------------------------------------  # Start with the original input image and apply the image enhancement # algorithm twice, being careful to account for the infinite size of the # images  img <- enhance_image(input, 2, algorithm)  expand.grid(seq_len(nrow(img)), seq_len(nrow(img))) |>   setNames(c(\"row\", \"col\")) |>   dplyr::left_join(which(img == \"#\", arr.ind = TRUE) |>                      cbind.data.frame(what = \"hash\"), by = c(\"row\", \"col\")) |>   dplyr::mutate(what = dplyr::case_when(is.na(what) ~ \"dot\",                                         TRUE ~ what)) |>   ggplot2::ggplot() + ggplot2::theme_void() +   ggplot2::geom_tile(ggplot2::aes(x = row, y = col, fill = what)) +   ggplot2::scale_fill_manual(values = setNames(c(\"black\", \"white\"),                                                c(\"hash\", \"dot\"))) +   ggplot2::coord_fixed() +   ggplot2::theme(legend.position = \"none\") # How many pixels are lit in the resulting image? sum(img == \"#\") ## [1] 5663"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-2-16","dir":"Articles","previous_headings":"Day 20: Trench Map","what":"Part 2","title":"AoC 2021 (R)","text":"462.964 sec.","code":"# Start again with the original input image and apply the image enhancement algorithm 50 times img <- enhance_image(input, 50, algorithm)  # How many pixels are lit in the resulting image? sum(img == \"#\") ## [1] 19638"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-18","dir":"Articles","previous_headings":"Day 21: Dirac Dice","what":"Part 1","title":"AoC 2021 (R)","text":"0.048 sec.","code":"# Read in data ------------------------------------------------------------ dat <- here(\"inst\", \"2021\", \"day21.txt\") |>   readLines()  start <- dat |> vapply(function(x) gsub(\".*([0-9])$\", \"\\\\1\", x),                        character(1)) |>   as.numeric()  # Play a practice game using the deterministic 100-sided die --------------  pos1 <- start[1] pos2 <- start[2] score1 <- 0 score2 <- 0 i <- 0  while (all(c(score1, score2) < 1000)) {   i <- i + 1    if (i%%2 != 0) {     pos1 <- pos1 + sum(((i * 3) - 2):(i * 3))     pos1 <- dplyr::if_else(pos1 > 10, pos1%%10, pos1)     pos1 <- dplyr::if_else(pos1 == 0, 10, pos1) # since pos1 = 100 returns 0     score1 <- score1 + pos1    } else {     pos2 <- pos2 + sum(((i * 3) - 2):(i * 3))     pos2 <- dplyr::if_else(pos2 > 10, pos2%%10, pos2)     pos2 <- dplyr::if_else(pos2 == 0, 10, pos2)     score2 <- score2 + pos2   } }  # The moment either player wins, what do you get if you multiply the score of # the losing player by the number of times the die was rolled during the game?  min(score1, score2) * i * 3 ## [1] 598416"},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-19","dir":"Articles","previous_headings":"Day 22: Reactor Reboot","what":"Part 1","title":"AoC 2021 (R)","text":"0.175 sec.","code":"# Read in data ------------------------------------------------------------  dat <- here(\"inst\", \"2021\", \"day22.txt\") |>   readLines()  # Define functions --------------------------------------------------------  tidy_day22 <- function(dat, limit) {   out <- dat |> data.frame() |>     setNames(\"x\") |>     tidyr::separate(x, c(\"on\", \"x\"), \" \") |>     tidyr::separate(x, c(\"x\", \"y\", \"z\"), \",\") |>     dplyr::mutate(on = dplyr::if_else(on == \"on\", TRUE, FALSE)) |>     dplyr::mutate_if(is.character, \\(z)                      gsub(\"^.*=(-?\\\\d*\\\\.\\\\.-?\\\\d*)$\", \"\\\\1\", z)) |>     tidyr::separate(x, c(\"x1\", \"x2\"), \"\\\\.\\\\.\") |>     tidyr::separate(y, c(\"y1\", \"y2\"), \"\\\\.\\\\.\") |>     tidyr::separate(z, c(\"z1\", \"z2\"), \"\\\\.\\\\.\") |>     dplyr::mutate_if(is.character, as.numeric)    if(missing(limit)) {     limit <- max(max(out), abs(min(out)))   }   dplyr::mutate_if(out, is.numeric, \\(z) z + limit + 1) }  get_indices <- function(df, reactor) {   reactor[df$x1:df$x2, df$y1:df$y2, df$z1:df$z2] <- df$on   reactor }  # Run simulation ----------------------------------------------------------  dat <- tidy_day22(dat, 50)  # Execute the reboot steps  reactor <- array(FALSE, dim = c(101, 101, 101))  for (i in seq_len(nrow(dat))) {   # Are any coordintes outside the range?   test <- dat[i, ] |>     unlist() |>     tail(-1) |>     {\\(x) dplyr::between(x, 1, max(dim(reactor)))}() |>     all()    if (test) {     reactor <- get_indices(dat[i, ], reactor)   } else {     next   } }  # Considering only cubes in the region x=-50..50,y=-50..50,z=-50..50, how many # cubes are on?  sum(reactor) ## [1] 644257"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"part-1-22","dir":"Articles","previous_headings":"Day 25: Sea Cucumber","what":"Part 1","title":"AoC 2021 (R)","text":"15.819 sec.","code":"# Read in data ------------------------------------------------------------  # Read in cucumber positions dat <- readLines(here(\"inst\", \"2021\", \"day25.txt\")) |>   strsplit(\"\") |>   do.call(what = rbind)  east_cucumbers <- which(dat == \">\", arr.ind = TRUE) |>   data.frame() |>   dplyr::mutate(type = \"east\") south_cucumbers <- which(dat == \"v\", arr.ind = TRUE) |>   data.frame() |>   dplyr::mutate(type = \"south\") cucumbers <- rbind(east_cucumbers, south_cucumbers) |>   dplyr::mutate_if(is.numeric, as.double)  # Define functions --------------------------------------------------------  sea_cucumbers <- R6::R6Class(\"cucumbers\", list(   dat = NULL,   cucumbers = NULL,   continue_east = NULL,   continue_south = NULL,   plot = NULL,    initialize = function(dat, cucumbers) {     self$dat <- dat     self$cucumbers <- dplyr::mutate(cucumbers, id = dplyr::row_number())     self$continue_east <- TRUE     self$continue_south <- TRUE     invisible(self)   },    print = function(...) {     cat(\"\\n\")     for (i in seq_len(nrow(self$dat))){       cat(self$dat[i, ], \"\\n\")     }     invisible(self)   },    move_east = function() {     dat <- self$dat     cucumbers <- self$cucumbers     boundary <- ncol(dat) + 1      # Determine which cucumbers move     tmp <- cucumbers |>       dplyr::mutate(prev = col,                     col = dplyr::case_when(type == \"east\" ~ col + 1,                                            TRUE ~ col)) |>       dplyr::mutate(col = dplyr::case_when(col == boundary ~ 1,                                            TRUE ~ col))      # These do     moved <- tmp |>       dplyr::filter(type == \"east\") |>       dplyr::anti_join(cucumbers, by = c(\"row\", \"col\"))      # These don't     stationary <- dplyr::anti_join(cucumbers,                                    dplyr::select(moved, -prev), by = c(\"id\"))      # Move cucumbers east     dat[as.matrix(dplyr::select(moved, row, col))] <- \">\"      # Place a dot in their previous position     prev <- dplyr::select(moved, row, prev)     dat[as.matrix(prev)] <- \".\"      # Update the cucumber list     updated_cucumbers <- moved |>       dplyr::select(-prev) |>       rbind(stationary)      # Update object     self$dat <- dat     self$cucumbers <- updated_cucumbers     self$continue_east <- nrow(moved) > 0      invisible(self)   },    move_south = function(display = FALSE) {     dat <- self$dat     cucumbers <- self$cucumbers     boundary <- nrow(dat) + 1      # Determine which cucumbers move     tmp <- cucumbers |>       dplyr::mutate(prev = row,                     row = dplyr::case_when(type == \"south\" ~ row + 1,                                            TRUE ~ row)) |>       dplyr::mutate(row = dplyr::case_when(row == boundary ~ 1,                                            TRUE ~ row))      # These do     moved <- tmp |>       dplyr::filter(type == \"south\") |>       dplyr::anti_join(cucumbers, by = c(\"row\", \"col\"))      # These don't     stationary <- dplyr::anti_join(cucumbers,                                    dplyr::select(moved, -prev), by = c(\"id\"))      # Move cucumbers south     dat[as.matrix(dplyr::select(moved, row, col))] <- \"v\"      # Place a dot in their previous position     prev <- dplyr::select(moved, prev, col)     dat[as.matrix(prev)] <- \".\"      # Update the cucumber list     updated_cucumbers <- moved |>       dplyr::select(-prev) |>       rbind(stationary)      # Update object     self$dat <- dat     self$cucumbers <- updated_cucumbers     self$continue_south <-  nrow(moved) > 0      # Print to console     if (display) print(self)      invisible(self)   },    gg_cucumbers = function() {     dat <- self$dat     cucumbers <- self$cucumbers      rows <- seq_len(nrow(dat))     cols <- seq_len(ncol(dat))      fill <- c(\"#489FB5\", \"#EDE7E3\", \"#FFA62B\")      cucumbers |>       dplyr::select(-id) |>       tidyr::complete(row = rows, col = cols,                       fill = list(type = \"empty\")) |>       dplyr::mutate(text = dplyr::case_when(type == \"south\" ~ \"v\",                                             type == \"east\" ~ \">\",                                             TRUE ~ \"\")) |>       ggplot2::ggplot(ggplot2::aes(x = col, y = row, fill = type)) +       ggplot2::theme_void() +  ggplot2::coord_fixed() +       ggplot2::scale_y_reverse() +       ggplot2::scale_fill_manual(values = fill) +       ggplot2::geom_tile() +       ggplot2::geom_text(ggplot2::aes(label = text)) +       ggplot2::theme(legend.position = \"none\")   } ))  # Run simulation ----------------------------------------------------------  # Initialise variables track_cucumbers <- sea_cucumbers$new(dat, cucumbers) continue <- TRUE i <- 0  # Find somewhere safe to land your submarine  while (continue) {   i <- i + 1   # cat(\"\\r\", i)   track_cucumbers$move_east()   track_cucumbers$move_south()   continue <- track_cucumbers$continue_east | track_cucumbers$continue_south }  # What is the first step on which no sea cucumbers move? i ## [1] 530"},{"path":"http://sonia-mitchell.com/adventofcode/articles/2021.html","id":"test-data","dir":"Articles","previous_headings":"Day 25: Sea Cucumber","what":"Test data","title":"AoC 2021 (R)","text":"Test dataset","code":"knitr::include_graphics(\"recording.gif\")"},{"path":"http://sonia-mitchell.com/adventofcode/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sonia Mitchell. Maintainer, author.","code":""},{"path":"http://sonia-mitchell.com/adventofcode/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mitchell S (2022). adventofcode: Advent Code solutions. R package version 0.1.0, http://sonia-mitchell.com/adventofcode.","code":"@Manual{,   title = {adventofcode: My Advent of Code solutions},   author = {Sonia Mitchell},   year = {2022},   note = {R package version 0.1.0},   url = {http://sonia-mitchell.com/adventofcode}, }"},{"path":"http://sonia-mitchell.com/adventofcode/index.html","id":"adventofcode","dir":"","previous_headings":"","what":"My Advent of Code solutions","title":"My Advent of Code solutions","text":"repository contains attempts solving Advent Code programming puzzles Eric Wastl. AoC-2021: solutions R AoC-2020: solutions Julia AoC-2019: solutions Python","code":""},{"path":"http://sonia-mitchell.com/adventofcode/reference/adventofcode-package.html","id":null,"dir":"Reference","previous_headings":"","what":"adventofcode — adventofcode-package","title":"adventofcode — adventofcode-package","text":"adventofcode solutions R","code":""},{"path":"http://sonia-mitchell.com/adventofcode/reference/adventofcode-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"adventofcode — adventofcode-package","text":"https://adventofcode.com/2021","code":""},{"path":[]},{"path":"http://sonia-mitchell.com/adventofcode/reference/adventofcode-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"adventofcode — adventofcode-package","text":"Maintainer: Sonia Mitchell sonia.mitchell@glasgow.ac.uk (ORCID)","code":""}]
